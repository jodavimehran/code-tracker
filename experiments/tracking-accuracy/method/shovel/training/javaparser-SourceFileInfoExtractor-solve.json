{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "SourceFileInfoExtractor.java",
  "functionName": "solve",
  "functionId": "solve___node-Node",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java",
  "functionStartLine": 114,
  "functionEndLine": 138,
  "numCommitsSeen": 59,
  "timeTaken": 735,
  "changeHistory": [
    "b54617e765d73b3ce0d187cf12ad8da382bce439",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "53afb5bd2717dfdefd3c3c37fa8520b5482082dd",
    "3e4b012ca278ee33e9e02984367028cb1adf4bf5",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "29909336231ebe9473edc4bfaaccdbfdebceb72a",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "9ad141ca3325e35ce5e1348f782c5dcc93dc13af",
    "4b4544995752d3f5be9519a472d4b1810f1a6d1c",
    "34c91d23e99607ae236a5a5ef74ea2ac60befa7b",
    "37f93be6476b00be051173d0cde614fc8a3677e5",
    "3a53155f2cd5727b9b0bcf7ccaf9bd24256f8adb",
    "eec165d9e3ef0ab1d93f69a231964984a3379762",
    "558fc9b4f808d718b9b266071078752ba68d4203",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
    "1ae290f6f5e0c7ba62eab797aba22308957b9257",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
    "ee35b15a04539af508d29081ac5c7f8f6fadba4a",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
    "31b108cbfd418f43e7b568374af2e635a580e171",
    "279b3ac52fb15a8c1a055a1b6e8d31cec0f2e96c",
    "bac18a129c45335e69d811b3872fcb938e1f0ff8",
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
    "bf2f13e26271634e5c0742392c1f5d0de2cad171",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba"
  ],
  "changeHistoryShort": {
    "b54617e765d73b3ce0d187cf12ad8da382bce439": "Ybodychange",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650": "Ybodychange",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "53afb5bd2717dfdefd3c3c37fa8520b5482082dd": "Ybodychange",
    "3e4b012ca278ee33e9e02984367028cb1adf4bf5": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ybodychange",
    "29909336231ebe9473edc4bfaaccdbfdebceb72a": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "9ad141ca3325e35ce5e1348f782c5dcc93dc13af": "Ybodychange",
    "4b4544995752d3f5be9519a472d4b1810f1a6d1c": "Ybodychange",
    "34c91d23e99607ae236a5a5ef74ea2ac60befa7b": "Ybodychange",
    "37f93be6476b00be051173d0cde614fc8a3677e5": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "3a53155f2cd5727b9b0bcf7ccaf9bd24256f8adb": "Ybodychange",
    "eec165d9e3ef0ab1d93f69a231964984a3379762": "Ybodychange",
    "558fc9b4f808d718b9b266071078752ba68d4203": "Ybodychange",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": "Ybodychange",
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807": "Ybodychange",
    "1ae290f6f5e0c7ba62eab797aba22308957b9257": "Ybodychange",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": "Ybodychange",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": "Ybodychange",
    "ee35b15a04539af508d29081ac5c7f8f6fadba4a": "Ybodychange",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": "Ybodychange",
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451": "Ybodychange",
    "31b108cbfd418f43e7b568374af2e635a580e171": "Ybodychange",
    "279b3ac52fb15a8c1a055a1b6e8d31cec0f2e96c": "Ybodychange",
    "bac18a129c45335e69d811b3872fcb938e1f0ff8": "Ybodychange",
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd": "Ybodychange",
    "bf2f13e26271634e5c0742392c1f5d0de2cad171": "Ybodychange",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b54617e765d73b3ce0d187cf12ad8da382bce439": {
      "type": "Ybodychange",
      "commitMessage": "Cleaning up JSS code\n",
      "commitDate": "2018-02-03, 1:46 p.m.",
      "commitName": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018-01-10, 7:52 a.m.",
      "commitNameOld": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 24.25,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((requireParentNode(node) instanceof ImportDeclaration) || (requireParentNode(node) instanceof Expression)\n                    || (requireParentNode(node) instanceof MethodDeclaration)\n                    || (requireParentNode(node) instanceof PackageDeclaration)) {\n                // skip\n            } else if ((requireParentNode(node) instanceof Statement) || (requireParentNode(node) instanceof VariableDeclarator)) {\n                try {\n                    ResolvedType ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().get().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 114,
      "functionName": "solve",
      "diff": "@@ -1,25 +1,25 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration) node);\n         } else if (node instanceof Expression) {\n-            if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n-                    || (getParentNode(node) instanceof MethodDeclaration)\n-                    || (getParentNode(node) instanceof PackageDeclaration)) {\n+            if ((requireParentNode(node) instanceof ImportDeclaration) || (requireParentNode(node) instanceof Expression)\n+                    || (requireParentNode(node) instanceof MethodDeclaration)\n+                    || (requireParentNode(node) instanceof PackageDeclaration)) {\n                 // skip\n-            } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n+            } else if ((requireParentNode(node) instanceof Statement) || (requireParentNode(node) instanceof VariableDeclarator)) {\n                 try {\n                     ResolvedType ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     out.println(\"  Line \" + node.getRange().get().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe) {\n                     unsupported++;\n                     err.println(upe.getMessage());\n                     throw upe;\n                 } catch (RuntimeException re) {\n                     ko++;\n                     err.println(re.getMessage());\n                     throw re;\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018-01-10, 7:52 a.m.",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018-01-10, 3:01 a.m.",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                    || (getParentNode(node) instanceof MethodDeclaration)\n                    || (getParentNode(node) instanceof PackageDeclaration)) {\n                // skip\n            } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                try {\n                    ResolvedType ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().get().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 113,
      "functionName": "solve",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java"
      }
    },
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650": {
      "type": "Ybodychange",
      "commitMessage": "correcting module core to use new classes\n",
      "commitDate": "2017-09-29, 2:07 a.m.",
      "commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-01-10, 5:19 p.m.",
      "commitNameOld": "dd73ec538fbacfc1a05acb6d0ac35da3b4e87bc3",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 261.32,
      "commitsBetweenForRepo": 230,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                    || (getParentNode(node) instanceof MethodDeclaration)\n                    || (getParentNode(node) instanceof PackageDeclaration)) {\n                // skip\n            } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                try {\n                    ResolvedType ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().get().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 113,
      "functionName": "solve",
      "diff": "@@ -1,25 +1,25 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration) node);\n         } else if (node instanceof Expression) {\n             if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                     || (getParentNode(node) instanceof MethodDeclaration)\n                     || (getParentNode(node) instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                 try {\n-                    Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n+                    ResolvedType ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     out.println(\"  Line \" + node.getRange().get().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe) {\n                     unsupported++;\n                     err.println(upe.getMessage());\n                     throw upe;\n                 } catch (RuntimeException re) {\n                     ko++;\n                     err.println(re.getMessage());\n                     throw re;\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": {
      "type": "Ybodychange",
      "commitMessage": "porting to JavaParser 3.0.0 RC2\n",
      "commitDate": "2016-12-13, 2:42 p.m.",
      "commitName": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-09, 12:15 p.m.",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 34.1,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                    || (getParentNode(node) instanceof MethodDeclaration)\n                    || (getParentNode(node) instanceof PackageDeclaration)) {\n                // skip\n            } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                try {\n                    Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().get().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 112,
      "functionName": "solve",
      "diff": "@@ -1,25 +1,25 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration) node);\n         } else if (node instanceof Expression) {\n             if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                     || (getParentNode(node) instanceof MethodDeclaration)\n                     || (getParentNode(node) instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                 try {\n                     Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n-                    out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n+                    out.println(\"  Line \" + node.getRange().get().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe) {\n                     unsupported++;\n                     err.println(upe.getMessage());\n                     throw upe;\n                 } catch (RuntimeException re) {\n                     ko++;\n                     err.println(re.getMessage());\n                     throw re;\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016-10-20, 2:39 a.m.",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 2:32 a.m.",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                    || (getParentNode(node) instanceof MethodDeclaration)\n                    || (getParentNode(node) instanceof PackageDeclaration)) {\n                // skip\n            } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                try {\n                    Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 110,
      "functionName": "solve",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/SourceFileInfoExtractor.java"
      }
    },
    "53afb5bd2717dfdefd3c3c37fa8520b5482082dd": {
      "type": "Ybodychange",
      "commitMessage": "changing the ordere of nodes in tests\n",
      "commitDate": "2016-10-19, 1:36 p.m.",
      "commitName": "53afb5bd2717dfdefd3c3c37fa8520b5482082dd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:36 p.m.",
      "commitNameOld": "3e4b012ca278ee33e9e02984367028cb1adf4bf5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                    || (getParentNode(node) instanceof MethodDeclaration)\n                    || (getParentNode(node) instanceof PackageDeclaration)) {\n                // skip\n            } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                try {\n                    Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 110,
      "functionName": "solve",
      "diff": "@@ -1,28 +1,25 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration) node);\n         } else if (node instanceof Expression) {\n             if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                     || (getParentNode(node) instanceof MethodDeclaration)\n                     || (getParentNode(node) instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                 try {\n                     Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe) {\n                     unsupported++;\n                     err.println(upe.getMessage());\n                     throw upe;\n                 } catch (RuntimeException re) {\n                     ko++;\n                     err.println(re.getMessage());\n                     throw re;\n                 }\n             }\n         }\n-        for (Node child : node.getChildrenNodes()) {\n-            solve(child);\n-        }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3e4b012ca278ee33e9e02984367028cb1adf4bf5": {
      "type": "Ybodychange",
      "commitMessage": "use NodeNavigator.getParentNode\n",
      "commitDate": "2016-10-19, 1:36 p.m.",
      "commitName": "3e4b012ca278ee33e9e02984367028cb1adf4bf5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:33 p.m.",
      "commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n                    || (getParentNode(node) instanceof MethodDeclaration)\n                    || (getParentNode(node) instanceof PackageDeclaration)) {\n                // skip\n            } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                try {\n                    Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()) {\n            solve(child);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 108,
      "functionName": "solve",
      "diff": "@@ -1,28 +1,28 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration) node);\n         } else if (node instanceof Expression) {\n-            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n-                    || (node.getParentNode() instanceof MethodDeclaration)\n-                    || (node.getParentNode() instanceof PackageDeclaration)) {\n+            if ((getParentNode(node) instanceof ImportDeclaration) || (getParentNode(node) instanceof Expression)\n+                    || (getParentNode(node) instanceof MethodDeclaration)\n+                    || (getParentNode(node) instanceof PackageDeclaration)) {\n                 // skip\n-            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)) {\n+            } else if ((getParentNode(node) instanceof Statement) || (getParentNode(node) instanceof VariableDeclarator)) {\n                 try {\n                     Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe) {\n                     unsupported++;\n                     err.println(upe.getMessage());\n                     throw upe;\n                 } catch (RuntimeException re) {\n                     ko++;\n                     err.println(re.getMessage());\n                     throw re;\n                 }\n             }\n         }\n         for (Node child : node.getChildrenNodes()) {\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ybodychange",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016-10-13, 4:11 p.m.",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-09, 1:00 p.m.",
      "commitNameOld": "91127219c066635d47cfe8d849a2814308d14cdc",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 4.13,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)) {\n                try {\n                    Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()) {\n            solve(child);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 90,
      "functionName": "solve",
      "diff": "@@ -1,28 +1,28 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration) node);\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)) {\n                 try {\n-                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n+                    Type ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe) {\n                     unsupported++;\n                     err.println(upe.getMessage());\n                     throw upe;\n                 } catch (RuntimeException re) {\n                     ko++;\n                     err.println(re.getMessage());\n                     throw re;\n                 }\n             }\n         }\n         for (Node child : node.getChildrenNodes()) {\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "29909336231ebe9473edc4bfaaccdbfdebceb72a": {
      "type": "Ybodychange",
      "commitMessage": "updating to JavaParser 3.0.0-alpha.2\n",
      "commitDate": "2016-09-23, 1:29 p.m.",
      "commitName": "29909336231ebe9473edc4bfaaccdbfdebceb72a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-22, 5:45 a.m.",
      "commitNameOld": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 306.28,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)) {\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()) {\n            solve(child);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 82,
      "functionName": "solve",
      "diff": "@@ -1,28 +1,28 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration) node);\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)) {\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n-                    out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n+                    out.println(\"  Line \" + node.getRange().begin.line + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe) {\n                     unsupported++;\n                     err.println(upe.getMessage());\n                     throw upe;\n                 } catch (RuntimeException re) {\n                     ko++;\n                     err.println(re.getMessage());\n                     throw re;\n                 }\n             }\n         }\n         for (Node child : node.getChildrenNodes()) {\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015-11-13, 4:12 a.m.",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 3:53 a.m.",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration) node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)) {\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe) {\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re) {\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()) {\n            solve(child);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 83,
      "functionName": "solve",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java"
      }
    },
    "9ad141ca3325e35ce5e1348f782c5dcc93dc13af": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeUsage.getQualifiedName\n",
      "commitDate": "2015-10-30, 5:25 a.m.",
      "commitName": "9ad141ca3325e35ce5e1348f782c5dcc93dc13af",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-29, 7:05 p.m.",
      "commitNameOld": "4b4544995752d3f5be9519a472d4b1810f1a6d1c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re){\n                    ko++;\n                    err.println(re.getMessage());\n                    throw re;\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 89,
      "functionName": "solve",
      "diff": "@@ -1,27 +1,28 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe){\n                     unsupported++;\n                     err.println(upe.getMessage());\n                     throw upe;\n                 } catch (RuntimeException re){\n                     ko++;\n                     err.println(re.getMessage());\n+                    throw re;\n                 }\n             }\n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4b4544995752d3f5be9519a472d4b1810f1a6d1c": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeUsage.prettyPrint\n",
      "commitDate": "2015-10-29, 7:05 p.m.",
      "commitName": "4b4544995752d3f5be9519a472d4b1810f1a6d1c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-28, 11:18 a.m.",
      "commitNameOld": "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.32,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    unsupported++;\n                    err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re){\n                    ko++;\n                    err.println(re.getMessage());\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 89,
      "functionName": "solve",
      "diff": "@@ -1,26 +1,27 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n-                    out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n+                    out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.describe());\n                     ok++;\n                 } catch (UnsupportedOperationException upe){\n                     unsupported++;\n                     err.println(upe.getMessage());\n+                    throw upe;\n                 } catch (RuntimeException re){\n                     ko++;\n                     err.println(re.getMessage());\n                 }\n             }\n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34c91d23e99607ae236a5a5ef74ea2ac60befa7b": {
      "type": "Ybodychange",
      "commitMessage": "avoid printing filename in the analysis output\n",
      "commitDate": "2015-08-26, 5:44 a.m.",
      "commitName": "34c91d23e99607ae236a5a5ef74ea2ac60befa7b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-26, 5:32 a.m.",
      "commitNameOld": "37f93be6476b00be051173d0cde614fc8a3677e5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    unsupported++;\n                    err.println(upe.getMessage());\n                } catch (RuntimeException re){\n                    ko++;\n                    err.println(re.getMessage());\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
      "functionStartLine": 89,
      "functionName": "solve",
      "diff": "@@ -1,26 +1,26 @@\n     private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n-                    //out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n+                    out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                 } catch (UnsupportedOperationException upe){\n                     unsupported++;\n                     err.println(upe.getMessage());\n                 } catch (RuntimeException re){\n                     ko++;\n                     err.println(re.getMessage());\n                 }\n             }\n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "37f93be6476b00be051173d0cde614fc8a3677e5": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "add tests on parsing JavaParser\n",
      "commitDate": "2015-08-26, 5:32 a.m.",
      "commitName": "37f93be6476b00be051173d0cde614fc8a3677e5",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "add tests on parsing JavaParser\n",
          "commitDate": "2015-08-26, 5:32 a.m.",
          "commitName": "37f93be6476b00be051173d0cde614fc8a3677e5",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-25, 5:08 p.m.",
          "commitNameOld": "69308a5f2ce954f2aa044d1162f5163fe4370e8c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.52,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    //out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    unsupported++;\n                    err.println(upe.getMessage());\n                } catch (RuntimeException re){\n                    ko++;\n                    err.println(re.getMessage());\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
          "functionStartLine": 83,
          "functionName": "solve",
          "diff": "@@ -1,52 +1,26 @@\n-    private static void solve(Node node) {\n+    private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n-        }  else if (node instanceof FieldDeclaration) {\n-            solveField(node);\n-            return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n-                    //System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n+                    //out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                 } catch (UnsupportedOperationException upe){\n-                    String line \u003d upe.getStackTrace()[0].toString();\n-                    if (!unsupportedMap.containsKey(line)) {\n-                        unsupportedMap.put(line, 0);\n-                    }\n-                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n-                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n-                        throw upe;\n-                    }\n-                    System.err.println(upe.getMessage());\n-                    throw upe;\n+                    err.println(upe.getMessage());\n                 } catch (RuntimeException re){\n-                    String line;\n-                    line \u003d re.getStackTrace()[0].toString();\n-                    if (!koMap.containsKey(line)) {\n-                        koMap.put(line, 0);\n-                    }\n-                    koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n-                    /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n-                        throw re;\n-                    }*/\n-                    //re.printStackTrace();\n-                    System.err.println(re.getMessage());\n-                    throw re;\n+                    err.println(re.getMessage());\n                 }\n-            } else {\n-                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n-\n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
            "newPath": "src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
            "oldMethodName": "solve",
            "newMethodName": "solve"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "add tests on parsing JavaParser\n",
          "commitDate": "2015-08-26, 5:32 a.m.",
          "commitName": "37f93be6476b00be051173d0cde614fc8a3677e5",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-25, 5:08 p.m.",
          "commitNameOld": "69308a5f2ce954f2aa044d1162f5163fe4370e8c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.52,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    //out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    unsupported++;\n                    err.println(upe.getMessage());\n                } catch (RuntimeException re){\n                    ko++;\n                    err.println(re.getMessage());\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
          "functionStartLine": 83,
          "functionName": "solve",
          "diff": "@@ -1,52 +1,26 @@\n-    private static void solve(Node node) {\n+    private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n-        }  else if (node instanceof FieldDeclaration) {\n-            solveField(node);\n-            return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n-                    //System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n+                    //out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                 } catch (UnsupportedOperationException upe){\n-                    String line \u003d upe.getStackTrace()[0].toString();\n-                    if (!unsupportedMap.containsKey(line)) {\n-                        unsupportedMap.put(line, 0);\n-                    }\n-                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n-                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n-                        throw upe;\n-                    }\n-                    System.err.println(upe.getMessage());\n-                    throw upe;\n+                    err.println(upe.getMessage());\n                 } catch (RuntimeException re){\n-                    String line;\n-                    line \u003d re.getStackTrace()[0].toString();\n-                    if (!koMap.containsKey(line)) {\n-                        koMap.put(line, 0);\n-                    }\n-                    koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n-                    /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n-                        throw re;\n-                    }*/\n-                    //re.printStackTrace();\n-                    System.err.println(re.getMessage());\n-                    throw re;\n+                    err.println(re.getMessage());\n                 }\n-            } else {\n-                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n-\n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private, static]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "add tests on parsing JavaParser\n",
          "commitDate": "2015-08-26, 5:32 a.m.",
          "commitName": "37f93be6476b00be051173d0cde614fc8a3677e5",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-25, 5:08 p.m.",
          "commitNameOld": "69308a5f2ce954f2aa044d1162f5163fe4370e8c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.52,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    //out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    unsupported++;\n                    err.println(upe.getMessage());\n                } catch (RuntimeException re){\n                    ko++;\n                    err.println(re.getMessage());\n                }\n            }\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/SourceFileInfoExtractor.java",
          "functionStartLine": 83,
          "functionName": "solve",
          "diff": "@@ -1,52 +1,26 @@\n-    private static void solve(Node node) {\n+    private void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n-        }  else if (node instanceof FieldDeclaration) {\n-            solveField(node);\n-            return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n-                    //System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n+                    //out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                 } catch (UnsupportedOperationException upe){\n-                    String line \u003d upe.getStackTrace()[0].toString();\n-                    if (!unsupportedMap.containsKey(line)) {\n-                        unsupportedMap.put(line, 0);\n-                    }\n-                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n-                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n-                        throw upe;\n-                    }\n-                    System.err.println(upe.getMessage());\n-                    throw upe;\n+                    err.println(upe.getMessage());\n                 } catch (RuntimeException re){\n-                    String line;\n-                    line \u003d re.getStackTrace()[0].toString();\n-                    if (!koMap.containsKey(line)) {\n-                        koMap.put(line, 0);\n-                    }\n-                    koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n-                    /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n-                        throw re;\n-                    }*/\n-                    //re.printStackTrace();\n-                    System.err.println(re.getMessage());\n-                    throw re;\n+                    err.println(re.getMessage());\n                 }\n-            } else {\n-                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n-\n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "3a53155f2cd5727b9b0bcf7ccaf9bd24256f8adb": {
      "type": "Ybodychange",
      "commitMessage": "add more tests on param type substitution in return types\n",
      "commitDate": "2015-08-25, 8:56 a.m.",
      "commitName": "3a53155f2cd5727b9b0bcf7ccaf9bd24256f8adb",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-25, 5:57 a.m.",
      "commitNameOld": "eec165d9e3ef0ab1d93f69a231964984a3379762",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    //System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                        throw upe;\n                    }\n                    System.err.println(upe.getMessage());\n                    throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    line \u003d re.getStackTrace()[0].toString();\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n                        throw re;\n                    }*/\n                    //re.printStackTrace();\n                    System.err.println(re.getMessage());\n                    throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,52 +1,52 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     //System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                         throw upe;\n                     }\n                     System.err.println(upe.getMessage());\n-                    //throw upe;\n+                    throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n                     line \u003d re.getStackTrace()[0].toString();\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n                     /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n                         throw re;\n                     }*/\n                     //re.printStackTrace();\n                     System.err.println(re.getMessage());\n-                    //throw re;\n+                    throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eec165d9e3ef0ab1d93f69a231964984a3379762": {
      "type": "Ybodychange",
      "commitMessage": "consider array modifiers\n",
      "commitDate": "2015-08-25, 5:57 a.m.",
      "commitName": "eec165d9e3ef0ab1d93f69a231964984a3379762",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-25, 3:22 a.m.",
      "commitNameOld": "558fc9b4f808d718b9b266071078752ba68d4203",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    //System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                        throw upe;\n                    }\n                    System.err.println(upe.getMessage());\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    line \u003d re.getStackTrace()[0].toString();\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n                        throw re;\n                    }*/\n                    //re.printStackTrace();\n                    System.err.println(re.getMessage());\n                    //throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,56 +1,52 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n-                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n+                    //System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                         throw upe;\n                     }\n                     System.err.println(upe.getMessage());\n                     //throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n-                    if (re.getStackTrace().length \u003d\u003d 0) {\n-                        throw re;\n-                    } else {\n-                        line \u003d re.getStackTrace()[0].toString();\n-                    }\n+                    line \u003d re.getStackTrace()[0].toString();\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n                     /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n                         throw re;\n                     }*/\n                     //re.printStackTrace();\n                     System.err.println(re.getMessage());\n                     //throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "558fc9b4f808d718b9b266071078752ba68d4203": {
      "type": "Ybodychange",
      "commitMessage": "improve method type parameter substitution\n",
      "commitDate": "2015-08-25, 3:22 a.m.",
      "commitName": "558fc9b4f808d718b9b266071078752ba68d4203",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 4:42 p.m.",
      "commitNameOld": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.44,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                        throw upe;\n                    }\n                    System.err.println(upe.getMessage());\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    if (re.getStackTrace().length \u003d\u003d 0) {\n                        throw re;\n                    } else {\n                        line \u003d re.getStackTrace()[0].toString();\n                    }\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n                        throw re;\n                    }*/\n                    //re.printStackTrace();\n                    System.err.println(re.getMessage());\n                    //throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,56 +1,56 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n-                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n-                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                         throw upe;\n                     }\n+                    System.err.println(upe.getMessage());\n                     //throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n                     if (re.getStackTrace().length \u003d\u003d 0) {\n                         throw re;\n                     } else {\n                         line \u003d re.getStackTrace()[0].toString();\n                     }\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n                     /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n                         throw re;\n                     }*/\n-                    re.printStackTrace();\n-                   // throw re;\n+                    //re.printStackTrace();\n+                    System.err.println(re.getMessage());\n+                    //throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": {
      "type": "Ybodychange",
      "commitMessage": "considering method type parameters\n",
      "commitDate": "2015-08-24, 4:42 p.m.",
      "commitName": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 3:57 p.m.",
      "commitNameOld": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                        throw upe;\n                    }\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    if (re.getStackTrace().length \u003d\u003d 0) {\n                        throw re;\n                    } else {\n                        line \u003d re.getStackTrace()[0].toString();\n                    }\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n                        throw re;\n                    }*/\n                    re.printStackTrace();\n                   // throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,56 +1,56 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                     //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                         throw upe;\n                     }\n                     //throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n                     if (re.getStackTrace().length \u003d\u003d 0) {\n                         throw re;\n                     } else {\n                         line \u003d re.getStackTrace()[0].toString();\n                     }\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n-                    if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n+                    /*if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"cloneNodes\")){\n                         throw re;\n-                    }\n+                    }*/\n                     re.printStackTrace();\n                    // throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807": {
      "type": "Ybodychange",
      "commitMessage": "use qualified name when solving types\n",
      "commitDate": "2015-08-24, 3:57 p.m.",
      "commitName": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 3:37 p.m.",
      "commitNameOld": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                        throw upe;\n                    }\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    if (re.getStackTrace().length \u003d\u003d 0) {\n                        throw re;\n                    } else {\n                        line \u003d re.getStackTrace()[0].toString();\n                    }\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n                        throw re;\n                    }\n                    re.printStackTrace();\n                   // throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,55 +1,56 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                     //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                         throw upe;\n                     }\n                     //throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n                     if (re.getStackTrace().length \u003d\u003d 0) {\n                         throw re;\n                     } else {\n                         line \u003d re.getStackTrace()[0].toString();\n                     }\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n                     if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n                         throw re;\n                     }\n+                    re.printStackTrace();\n                    // throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ae290f6f5e0c7ba62eab797aba22308957b9257": {
      "type": "Ybodychange",
      "commitMessage": "consider method values of Enum\n",
      "commitDate": "2015-08-24, 3:37 p.m.",
      "commitName": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 3:19 p.m.",
      "commitNameOld": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                        throw upe;\n                    }\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    if (re.getStackTrace().length \u003d\u003d 0) {\n                        throw re;\n                    } else {\n                        line \u003d re.getStackTrace()[0].toString();\n                    }\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n                        throw re;\n                    }\n                   // throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,55 +1,55 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                     //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                         throw upe;\n                     }\n-                    throw upe;\n+                    //throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n                     if (re.getStackTrace().length \u003d\u003d 0) {\n                         throw re;\n                     } else {\n                         line \u003d re.getStackTrace()[0].toString();\n                     }\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n                     if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n                         throw re;\n                     }\n-                   throw re;\n+                   // throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": {
      "type": "Ybodychange",
      "commitMessage": "consider method override\n",
      "commitDate": "2015-08-24, 3:19 p.m.",
      "commitName": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 12:29 p.m.",
      "commitNameOld": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                        throw upe;\n                    }\n                    throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    if (re.getStackTrace().length \u003d\u003d 0) {\n                        throw re;\n                    } else {\n                        line \u003d re.getStackTrace()[0].toString();\n                    }\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n                        throw re;\n                    }\n                   throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,55 +1,55 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                     //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                         throw upe;\n                     }\n-                    //throw upe;\n+                    throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n                     if (re.getStackTrace().length \u003d\u003d 0) {\n                         throw re;\n                     } else {\n                         line \u003d re.getStackTrace()[0].toString();\n                     }\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n                     if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n                         throw re;\n                     }\n-                   // throw re;\n+                   throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": {
      "type": "Ybodychange",
      "commitMessage": "add test on switch on enum value\n",
      "commitDate": "2015-08-24, 12:29 p.m.",
      "commitName": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 10:31 a.m.",
      "commitNameOld": "ee35b15a04539af508d29081ac5c7f8f6fadba4a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                        throw upe;\n                    }\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    if (re.getStackTrace().length \u003d\u003d 0) {\n                        throw re;\n                    } else {\n                        line \u003d re.getStackTrace()[0].toString();\n                    }\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n                        throw re;\n                    }\n                   // throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,52 +1,55 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                     //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n-                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().startsWith(\"FOO\")){\n+                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().contains(\"FOO\")){\n                         throw upe;\n                     }\n                     //throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n                     if (re.getStackTrace().length \u003d\u003d 0) {\n                         throw re;\n                     } else {\n                         line \u003d re.getStackTrace()[0].toString();\n                     }\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n-                    throw re;\n+                    if (re.getMessage() !\u003d null \u0026\u0026 re.getMessage().contains(\"FOO\")){\n+                        throw re;\n+                    }\n+                   // throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee35b15a04539af508d29081ac5c7f8f6fadba4a": {
      "type": "Ybodychange",
      "commitMessage": "consider enum and constructors\n",
      "commitDate": "2015-08-24, 10:31 a.m.",
      "commitName": "ee35b15a04539af508d29081ac5c7f8f6fadba4a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 10:22 a.m.",
      "commitNameOld": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().startsWith(\"FOO\")){\n                        throw upe;\n                    }\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    if (re.getStackTrace().length \u003d\u003d 0) {\n                        throw re;\n                    } else {\n                        line \u003d re.getStackTrace()[0].toString();\n                    }\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,52 +1,52 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                     //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().startsWith(\"FOO\")){\n                         throw upe;\n                     }\n                     //throw upe;\n                 } catch (RuntimeException re){\n                     String line;\n                     if (re.getStackTrace().length \u003d\u003d 0) {\n                         throw re;\n                     } else {\n                         line \u003d re.getStackTrace()[0].toString();\n                     }\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n-                    //throw re;\n+                    throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": {
      "type": "Ybodychange",
      "commitMessage": "remove JavaParserFacade.convert\n",
      "commitDate": "2015-08-24, 10:22 a.m.",
      "commitName": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 5:28 p.m.",
      "commitNameOld": "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().startsWith(\"FOO\")){\n                        throw upe;\n                    }\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line;\n                    if (re.getStackTrace().length \u003d\u003d 0) {\n                        throw re;\n                    } else {\n                        line \u003d re.getStackTrace()[0].toString();\n                    }\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    //throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,47 +1,52 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                     //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n                     if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().startsWith(\"FOO\")){\n                         throw upe;\n                     }\n                     //throw upe;\n                 } catch (RuntimeException re){\n-                    String line \u003d re.getStackTrace()[0].toString();\n+                    String line;\n+                    if (re.getStackTrace().length \u003d\u003d 0) {\n+                        throw re;\n+                    } else {\n+                        line \u003d re.getStackTrace()[0].toString();\n+                    }\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n                     //throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0b5fa9e41aaf140b9a30c716ac7a74b24508451": {
      "type": "Ybodychange",
      "commitMessage": "completing various missing elements\n",
      "commitDate": "2015-08-23, 5:28 p.m.",
      "commitName": "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 3:27 p.m.",
      "commitNameOld": "31b108cbfd418f43e7b568374af2e635a580e171",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().startsWith(\"FOO\")){\n                        throw upe;\n                    }\n                    //throw upe;\n                } catch (RuntimeException re){\n                    String line \u003d re.getStackTrace()[0].toString();\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    //throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,44 +1,47 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n                     //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     String line \u003d upe.getStackTrace()[0].toString();\n                     if (!unsupportedMap.containsKey(line)) {\n                         unsupportedMap.put(line, 0);\n                     }\n                     unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n-                    throw upe;\n+                    if (upe.getMessage() !\u003d null \u0026\u0026 upe.getMessage().startsWith(\"FOO\")){\n+                        throw upe;\n+                    }\n+                    //throw upe;\n                 } catch (RuntimeException re){\n                     String line \u003d re.getStackTrace()[0].toString();\n                     if (!koMap.containsKey(line)) {\n                         koMap.put(line, 0);\n                     }\n                     koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n-                    throw re;\n+                    //throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "31b108cbfd418f43e7b568374af2e635a580e171": {
      "type": "Ybodychange",
      "commitMessage": "add StatementContextTest\n",
      "commitDate": "2015-08-23, 3:27 p.m.",
      "commitName": "31b108cbfd418f43e7b568374af2e635a580e171",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 10:03 a.m.",
      "commitNameOld": "279b3ac52fb15a8c1a055a1b6e8d31cec0f2e96c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    String line \u003d upe.getStackTrace()[0].toString();\n                    if (!unsupportedMap.containsKey(line)) {\n                        unsupportedMap.put(line, 0);\n                    }\n                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                    unsupported++;\n                    throw upe;\n                } catch (RuntimeException re){\n                    String line \u003d re.getStackTrace()[0].toString();\n                    if (!koMap.containsKey(line)) {\n                        koMap.put(line, 0);\n                    }\n                    koMap.put(line, koMap.get(line) + 1);\n                    ko++;\n                    throw re;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 69,
      "functionName": "solve",
      "diff": "@@ -1,32 +1,44 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n-                    System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n+                    //System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n+                    String line \u003d upe.getStackTrace()[0].toString();\n+                    if (!unsupportedMap.containsKey(line)) {\n+                        unsupportedMap.put(line, 0);\n+                    }\n+                    unsupportedMap.put(line, unsupportedMap.get(line) + 1);\n                     unsupported++;\n+                    throw upe;\n                 } catch (RuntimeException re){\n+                    String line \u003d re.getStackTrace()[0].toString();\n+                    if (!koMap.containsKey(line)) {\n+                        koMap.put(line, 0);\n+                    }\n+                    koMap.put(line, koMap.get(line) + 1);\n                     ko++;\n+                    throw re;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "279b3ac52fb15a8c1a055a1b6e8d31cec0f2e96c": {
      "type": "Ybodychange",
      "commitMessage": "avoid stack overflow on enum isAssignableBy\n",
      "commitDate": "2015-08-23, 10:03 a.m.",
      "commitName": "279b3ac52fb15a8c1a055a1b6e8d31cec0f2e96c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 9:43 a.m.",
      "commitNameOld": "bac18a129c45335e69d811b3872fcb938e1f0ff8",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                    System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                } catch (UnsupportedOperationException upe){\n                    unsupported++;\n                } catch (RuntimeException re){\n                    ko++;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 64,
      "functionName": "solve",
      "diff": "@@ -1,31 +1,32 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                 try {\n                     TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                     System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                     ok++;\n+                    System.out.println(\"OK \"+ok+\" KO \"+ko+\" unsupported \"+unsupported);\n                 } catch (UnsupportedOperationException upe){\n                     unsupported++;\n                 } catch (RuntimeException re){\n                     ko++;\n                 }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bac18a129c45335e69d811b3872fcb938e1f0ff8": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-23, 9:43 a.m.",
      "commitName": "bac18a129c45335e69d811b3872fcb938e1f0ff8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 6:34 a.m.",
      "commitNameOld": "46aefdd68f2f2597a19b72da36681123cb3090e6",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                try {\n                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n                    ok++;\n                } catch (UnsupportedOperationException upe){\n                    unsupported++;\n                } catch (RuntimeException re){\n                    ko++;\n                }\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 64,
      "functionName": "solve",
      "diff": "@@ -1,24 +1,31 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n         } else if (node instanceof Expression) {\n             if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                     || (node.getParentNode() instanceof MethodDeclaration)\n                     || (node.getParentNode() instanceof PackageDeclaration)) {\n                 // skip\n             } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                 //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n-                TypeUsage ref \u003d  JavaParserFacade.get(typeSolver).getType(node);\n-                System.out.println(\"  Line \" + node.getBeginLine()+\") \"+ node +\" \u003d\u003d\u003e \"+ref.prettyPrint());\n+                try {\n+                    TypeUsage ref \u003d JavaParserFacade.get(typeSolver).getType(node);\n+                    System.out.println(\"  Line \" + node.getBeginLine() + \") \" + node + \" \u003d\u003d\u003e \" + ref.prettyPrint());\n+                    ok++;\n+                } catch (UnsupportedOperationException upe){\n+                    unsupported++;\n+                } catch (RuntimeException re){\n+                    ko++;\n+                }\n             } else {\n                 //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n             }\n \n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-23, 3:50 a.m.",
      "commitName": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-22, 9:26 a.m.",
      "commitNameOld": "3ba679f8e97be3f70d1c93e131a4db34858ef330",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        } else if (node instanceof Expression) {\n            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n                    || (node.getParentNode() instanceof MethodDeclaration)\n                    || (node.getParentNode() instanceof PackageDeclaration)) {\n                // skip\n            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n                TypeUsage ref \u003d  JavaParserFacade.get(typeSolver).getType(node);\n                System.out.println(\"  Line \" + node.getBeginLine()+\") \"+ node +\" \u003d\u003d\u003e \"+ref.prettyPrint());\n            } else {\n                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n            }\n\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 59,
      "functionName": "solve",
      "diff": "@@ -1,11 +1,24 @@\n     private static void solve(Node node) {\n         if (node instanceof ClassOrInterfaceDeclaration) {\n             solveTypeDecl((ClassOrInterfaceDeclaration)node);\n         }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n             return;\n+        } else if (node instanceof Expression) {\n+            if ((node.getParentNode() instanceof ImportDeclaration) || (node.getParentNode() instanceof Expression)\n+                    || (node.getParentNode() instanceof MethodDeclaration)\n+                    || (node.getParentNode() instanceof PackageDeclaration)) {\n+                // skip\n+            } else if ((node.getParentNode() instanceof Statement) || (node.getParentNode() instanceof VariableDeclarator)){\n+                //System.out.println(node + \" GOOD from \" + node.getParentNode().getClass().getCanonicalName());\n+                TypeUsage ref \u003d  JavaParserFacade.get(typeSolver).getType(node);\n+                System.out.println(\"  Line \" + node.getBeginLine()+\") \"+ node +\" \u003d\u003d\u003e \"+ref.prettyPrint());\n+            } else {\n+                //System.out.println(node + \" ? from \" + node.getParentNode().getClass().getCanonicalName());\n+            }\n+\n         }\n         for (Node child : node.getChildrenNodes()){\n             solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bf2f13e26271634e5c0742392c1f5d0de2cad171": {
      "type": "Ybodychange",
      "commitMessage": "add JavaParserFacadeTest\n",
      "commitDate": "2015-08-22, 8:47 a.m.",
      "commitName": "bf2f13e26271634e5c0742392c1f5d0de2cad171",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-22, 6:08 a.m.",
      "commitNameOld": "feab46de5d87b02bf38b29962613676adf14f78a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n        }  else if (node instanceof FieldDeclaration) {\n            solveField(node);\n            return;\n        }\n        for (Node child : node.getChildrenNodes()){\n            solve(child);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 51,
      "functionName": "solve",
      "diff": "@@ -1,9 +1,11 @@\n     private static void solve(Node node) {\n-        if (node instanceof FieldDeclaration) {\n+        if (node instanceof ClassOrInterfaceDeclaration) {\n+            solveTypeDecl((ClassOrInterfaceDeclaration)node);\n+        }  else if (node instanceof FieldDeclaration) {\n             solveField(node);\n-        } else {\n-            for (Node child : node.getChildrenNodes()){\n-                solve(child);\n-            }\n+            return;\n+        }\n+        for (Node child : node.getChildrenNodes()){\n+            solve(child);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": {
      "type": "Yintroduced",
      "commitMessage": "add tests for static field access\n",
      "commitDate": "2015-08-21, 5:00 p.m.",
      "commitName": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,9 @@\n+    private static void solve(Node node) {\n+        if (node instanceof FieldDeclaration) {\n+            solveField(node);\n+        } else {\n+            for (Node child : node.getChildrenNodes()){\n+                solve(child);\n+            }\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private static void solve(Node node) {\n        if (node instanceof FieldDeclaration) {\n            solveField(node);\n        } else {\n            for (Node child : node.getChildrenNodes()){\n                solve(child);\n            }\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/ProjectResolver.java",
      "functionStartLine": 43,
      "functionName": "solve"
    }
  }
}