{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "LambdaExprContext.java",
  "functionName": "solveSymbolAsValue",
  "functionId": "solveSymbolAsValue___name-String__typeSolver-TypeSolver",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
  "functionStartLine": 56,
  "functionEndLine": 138,
  "numCommitsSeen": 60,
  "timeTaken": 902,
  "changeHistory": [
    "b54617e765d73b3ce0d187cf12ad8da382bce439",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "5d8d0cb7947efcf2282f7d056302dd905f348532",
    "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
    "0aaa5e5b086a557801d54f8a3ac236e08513e774",
    "acdac6790f4424f8097b3aa6c888e825cac485f9",
    "2082034e8c3eb434e3df25dd420c98cae5a6d518",
    "631896a1d2f34eed89c41cc717f463ebbd69e401",
    "dc093e9ac9ae3239375c654c4cfff92ee0fb3927",
    "6fcf6356a95a250db103245c1c5f2d596f9493d6",
    "ecc1af475857cf3c62b3a07eb35ad080ed435dea",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "967b0302143d4d6868c3d9035a8615ccfd198b6e",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
    "03e407957d600a18ef0a4a83224c17d155ef8645",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
    "70f3e66c944670a818922f101162226ef604b263",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
    "8d234965b572759181da7787fead07b225e9e5ca",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
    "e529ad59cb7c1766706162cbc3a4fca49cd88e3e",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f",
    "b36f33050149a62a5b3c8c7451ae93f736715029",
    "627b56302d259409e9bc50b20d77803484f18b5c",
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f"
  ],
  "changeHistoryShort": {
    "b54617e765d73b3ce0d187cf12ad8da382bce439": "Ybodychange",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "5d8d0cb7947efcf2282f7d056302dd905f348532": "Ybodychange",
    "5da7835cd514233e05ff8ceb07b4f82063b0d08e": "Ybodychange",
    "0aaa5e5b086a557801d54f8a3ac236e08513e774": "Ybodychange",
    "acdac6790f4424f8097b3aa6c888e825cac485f9": "Ybodychange",
    "2082034e8c3eb434e3df25dd420c98cae5a6d518": "Ybodychange",
    "631896a1d2f34eed89c41cc717f463ebbd69e401": "Ybodychange",
    "dc093e9ac9ae3239375c654c4cfff92ee0fb3927": "Ybodychange",
    "6fcf6356a95a250db103245c1c5f2d596f9493d6": "Ybodychange",
    "ecc1af475857cf3c62b3a07eb35ad080ed435dea": "Ybodychange",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "967b0302143d4d6868c3d9035a8615ccfd198b6e": "Ybodychange",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": "Ybodychange",
    "03e407957d600a18ef0a4a83224c17d155ef8645": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": "Ybodychange",
    "70f3e66c944670a818922f101162226ef604b263": "Ybodychange",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": "Ybodychange",
    "8d234965b572759181da7787fead07b225e9e5ca": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ybodychange",
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5": "Ybodychange",
    "e529ad59cb7c1766706162cbc3a4fca49cd88e3e": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f": "Ybodychange",
    "b36f33050149a62a5b3c8c7451ae93f736715029": "Yfilerename",
    "627b56302d259409e9bc50b20d77803484f18b5c": "Ybodychange",
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b54617e765d73b3ce0d187cf12ad8da382bce439": {
      "type": "Ybodychange",
      "commitMessage": "Cleaning up JSS code\n",
      "commitDate": "2018-02-03, 1:46 p.m.",
      "commitName": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018-01-10, 7:52 a.m.",
      "commitNameOld": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 24.25,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (requireParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) requireParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n\n                        // Get the functional method in order for us to resolve it\u0027s type arguments properly\n                        Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                        if (functionalMethodOpt.isPresent()){\n                            MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n\n                            // Resolve each type variable of the lambda, and use this later to infer the type of each\n                            // implicit parameter\n                            inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n\n                            // Find the position of this lambda argument\n                            boolean found \u003d false;\n                            int lambdaParamIndex;\n                            for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                    found \u003d true;\n                                    break;\n                                }\n                            }\n                            if (!found) { return Optional.empty(); }\n\n                            // Now resolve the argument type using the inference context\n                            ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n\n                            ResolvedLambdaConstraintType conType;\n                            if (argType.isWildcard()){\n                                conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                            } else {\n                                conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                            }\n                            Value value \u003d new Value(conType, name);\n                            return Optional.of(value);\n                        } else{\n                            return Optional.empty();\n                        }\n                    } else if (requireParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) requireParentNode(wrappedNode);\n                        ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                            if (lambdaType.isReferenceType()) {\n                                for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n                                        ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 56,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,83 +1,83 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n-                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n-                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n+                    if (requireParentNode(wrappedNode) instanceof MethodCallExpr) {\n+                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) requireParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n \n                         // Get the functional method in order for us to resolve it\u0027s type arguments properly\n                         Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                         if (functionalMethodOpt.isPresent()){\n                             MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n \n                             // Resolve each type variable of the lambda, and use this later to infer the type of each\n                             // implicit parameter\n                             inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n \n                             // Find the position of this lambda argument\n                             boolean found \u003d false;\n                             int lambdaParamIndex;\n                             for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                 if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                     found \u003d true;\n                                     break;\n                                 }\n                             }\n                             if (!found) { return Optional.empty(); }\n \n                             // Now resolve the argument type using the inference context\n                             ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n \n                             ResolvedLambdaConstraintType conType;\n                             if (argType.isWildcard()){\n                                 conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                             } else {\n                                 conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                             }\n                             Value value \u003d new Value(conType, name);\n                             return Optional.of(value);\n                         } else{\n                             return Optional.empty();\n                         }\n-                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n-                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n+                    } else if (requireParentNode(wrappedNode) instanceof VariableDeclarator) {\n+                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) requireParentNode(wrappedNode);\n                         ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                             if (lambdaType.isReferenceType()) {\n                                 for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n                                         ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                         lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018-01-10, 7:52 a.m.",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018-01-10, 3:01 a.m.",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n\n                        // Get the functional method in order for us to resolve it\u0027s type arguments properly\n                        Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                        if (functionalMethodOpt.isPresent()){\n                            MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n\n                            // Resolve each type variable of the lambda, and use this later to infer the type of each\n                            // implicit parameter\n                            inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n\n                            // Find the position of this lambda argument\n                            boolean found \u003d false;\n                            int lambdaParamIndex;\n                            for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                    found \u003d true;\n                                    break;\n                                }\n                            }\n                            if (!found) { return Optional.empty(); }\n\n                            // Now resolve the argument type using the inference context\n                            ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n\n                            ResolvedLambdaConstraintType conType;\n                            if (argType.isWildcard()){\n                                conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                            } else {\n                                conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                            }\n                            Value value \u003d new Value(conType, name);\n                            return Optional.of(value);\n                        } else{\n                            return Optional.empty();\n                        }\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                            if (lambdaType.isReferenceType()) {\n                                for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n                                        ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
      }
    },
    "5d8d0cb7947efcf2282f7d056302dd905f348532": {
      "type": "Ybodychange",
      "commitMessage": "more work on converting to moved classes\n",
      "commitDate": "2017-09-28, 4:36 p.m.",
      "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017-03-10, 4:50 p.m.",
      "commitNameOld": "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 201.95,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n\n                        // Get the functional method in order for us to resolve it\u0027s type arguments properly\n                        Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                        if (functionalMethodOpt.isPresent()){\n                            MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n\n                            // Resolve each type variable of the lambda, and use this later to infer the type of each\n                            // implicit parameter\n                            inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n\n                            // Find the position of this lambda argument\n                            boolean found \u003d false;\n                            int lambdaParamIndex;\n                            for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                    found \u003d true;\n                                    break;\n                                }\n                            }\n                            if (!found) { return Optional.empty(); }\n\n                            // Now resolve the argument type using the inference context\n                            ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n\n                            ResolvedLambdaConstraintType conType;\n                            if (argType.isWildcard()){\n                                conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                            } else {\n                                conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                            }\n                            Value value \u003d new Value(conType, name);\n                            return Optional.of(value);\n                        } else{\n                            return Optional.empty();\n                        }\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                            if (lambdaType.isReferenceType()) {\n                                for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n                                        ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,83 +1,83 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n-            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n+            for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n-                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n+                        ResolvedType lambdaType \u003d methodUsage.getParamTypes().get(i);\n \n                         // Get the functional method in order for us to resolve it\u0027s type arguments properly\n                         Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                         if (functionalMethodOpt.isPresent()){\n                             MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n \n                             // Resolve each type variable of the lambda, and use this later to infer the type of each\n                             // implicit parameter\n                             inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n \n                             // Find the position of this lambda argument\n                             boolean found \u003d false;\n                             int lambdaParamIndex;\n                             for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                 if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                     found \u003d true;\n                                     break;\n                                 }\n                             }\n                             if (!found) { return Optional.empty(); }\n \n                             // Now resolve the argument type using the inference context\n-                            Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n+                            ResolvedType argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n \n-                            LambdaConstraintType conType;\n+                            ResolvedLambdaConstraintType conType;\n                             if (argType.isWildcard()){\n-                                conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                                conType \u003d ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                             } else {\n-                                conType \u003d LambdaConstraintType.bound(argType);\n+                                conType \u003d ResolvedLambdaConstraintType.bound(argType);\n                             }\n                             Value value \u003d new Value(conType, name);\n                             return Optional.of(value);\n                         } else{\n                             return Optional.empty();\n                         }\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n-                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n+                        ResolvedType t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n-                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n+                            ResolvedType lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n-                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n+                            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                             if (lambdaType.isReferenceType()) {\n-                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n-                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n-                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n+                                for (com.github.javaparser.utils.Pair\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n+                                    if (entry.b.isTypeVariable() \u0026\u0026 entry.b.asTypeParameter().declaredOnType()) {\n+                                        ResolvedType ot \u003d t.asReferenceType().typeParametersMap().getValue(entry.a);\n+                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5da7835cd514233e05ff8ceb07b4f82063b0d08e": {
      "type": "Ybodychange",
      "commitMessage": "Small readability changes\n",
      "commitDate": "2017-03-10, 4:50 p.m.",
      "commitName": "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-03-10, 2:11 p.m.",
      "commitNameOld": "0aaa5e5b086a557801d54f8a3ac236e08513e774",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n\n                        // Get the functional method in order for us to resolve it\u0027s type arguments properly\n                        Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                        if (functionalMethodOpt.isPresent()){\n                            MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n\n                            // Resolve each type variable of the lambda, and use this later to infer the type of each\n                            // implicit parameter\n                            inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n\n                            // Find the position of this lambda argument\n                            boolean found \u003d false;\n                            int lambdaParamIndex;\n                            for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                    found \u003d true;\n                                    break;\n                                }\n                            }\n                            if (!found) { return Optional.empty(); }\n\n                            // Now resolve the argument type using the inference context\n                            Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n\n                            LambdaConstraintType conType;\n                            if (argType.isWildcard()){\n                                conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                            } else {\n                                conType \u003d LambdaConstraintType.bound(argType);\n                            }\n                            Value value \u003d new Value(conType, name);\n                            return Optional.of(value);\n                        } else{\n                            return Optional.empty();\n                        }\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,83 +1,83 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n \n                         // Get the functional method in order for us to resolve it\u0027s type arguments properly\n                         Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                         if (functionalMethodOpt.isPresent()){\n                             MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                             InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n \n                             // Resolve each type variable of the lambda, and use this later to infer the type of each\n                             // implicit parameter\n                             inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n \n                             // Find the position of this lambda argument\n                             boolean found \u003d false;\n                             int lambdaParamIndex;\n                             for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                 if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n-                                    found \u003dtrue;\n+                                    found \u003d true;\n                                     break;\n                                 }\n                             }\n-                            if (!found) return Optional.empty();\n+                            if (!found) { return Optional.empty(); }\n \n                             // Now resolve the argument type using the inference context\n                             Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n \n                             LambdaConstraintType conType;\n                             if (argType.isWildcard()){\n                                 conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                             } else {\n                                 conType \u003d LambdaConstraintType.bound(argType);\n                             }\n                             Value value \u003d new Value(conType, name);\n                             return Optional.of(value);\n                         } else{\n                             return Optional.empty();\n                         }\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                         lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0aaa5e5b086a557801d54f8a3ac236e08513e774": {
      "type": "Ybodychange",
      "commitMessage": "Fix some issues with recovering types of lambda arguments\n",
      "commitDate": "2017-03-10, 2:11 p.m.",
      "commitName": "0aaa5e5b086a557801d54f8a3ac236e08513e774",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-03-09, 8:22 p.m.",
      "commitNameOld": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n\n                        // Get the functional method in order for us to resolve it\u0027s type arguments properly\n                        Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                        if (functionalMethodOpt.isPresent()){\n                            MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n\n                            // Resolve each type variable of the lambda, and use this later to infer the type of each\n                            // implicit parameter\n                            inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n\n                            // Find the position of this lambda argument\n                            boolean found \u003d false;\n                            int lambdaParamIndex;\n                            for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                    found \u003dtrue;\n                                    break;\n                                }\n                            }\n                            if (!found) return Optional.empty();\n\n                            // Now resolve the argument type using the inference context\n                            Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n\n                            LambdaConstraintType conType;\n                            if (argType.isWildcard()){\n                                conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                            } else {\n                                conType \u003d LambdaConstraintType.bound(argType);\n                            }\n                            Value value \u003d new Value(conType, name);\n                            return Optional.of(value);\n                        } else{\n                            return Optional.empty();\n                        }\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,56 +1,83 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                        Type argType \u003d lambdaType.asReferenceType().typeParametersValues().get(0);\n-                        LambdaConstraintType conType;\n-                        if (argType.isWildcard()){\n-                            conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n-                        } else {\n-                            conType \u003d LambdaConstraintType.bound(argType);\n+\n+                        // Get the functional method in order for us to resolve it\u0027s type arguments properly\n+                        Optional\u003cMethodUsage\u003e functionalMethodOpt \u003d FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n+                        if (functionalMethodOpt.isPresent()){\n+                            MethodUsage functionalMethod \u003d functionalMethodOpt.get();\n+                            InferenceContext inferenceContext \u003d new InferenceContext(MyObjectProvider.INSTANCE);\n+\n+                            // Resolve each type variable of the lambda, and use this later to infer the type of each\n+                            // implicit parameter\n+                            inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n+\n+                            // Find the position of this lambda argument\n+                            boolean found \u003d false;\n+                            int lambdaParamIndex;\n+                            for (lambdaParamIndex \u003d 0; lambdaParamIndex \u003c wrappedNode.getParameters().size(); lambdaParamIndex++){\n+                                if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n+                                    found \u003dtrue;\n+                                    break;\n+                                }\n+                            }\n+                            if (!found) return Optional.empty();\n+\n+                            // Now resolve the argument type using the inference context\n+                            Type argType \u003d inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n+\n+                            LambdaConstraintType conType;\n+                            if (argType.isWildcard()){\n+                                conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                            } else {\n+                                conType \u003d LambdaConstraintType.bound(argType);\n+                            }\n+                            Value value \u003d new Value(conType, name);\n+                            return Optional.of(value);\n+                        } else{\n+                            return Optional.empty();\n                         }\n-                        Value value \u003d new Value(conType, name);\n-                        return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                         lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "acdac6790f4424f8097b3aa6c888e825cac485f9": {
      "type": "Ybodychange",
      "commitMessage": "Fixes for type inference\n",
      "commitDate": "2017-03-09, 8:22 p.m.",
      "commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-03-08, 10:31 p.m.",
      "commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Type argType \u003d lambdaType.asReferenceType().typeParametersValues().get(0);\n                        LambdaConstraintType conType;\n                        if (argType.isWildcard()){\n                            conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                        } else {\n                            conType \u003d LambdaConstraintType.bound(argType);\n                        }\n                        Value value \u003d new Value(conType, name);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 57,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,49 +1,56 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n+                        Type argType \u003d lambdaType.asReferenceType().typeParametersValues().get(0);\n+                        LambdaConstraintType conType;\n+                        if (argType.isWildcard()){\n+                            conType \u003d LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                        } else {\n+                            conType \u003d LambdaConstraintType.bound(argType);\n+                        }\n+                        Value value \u003d new Value(conType, name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                         lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2082034e8c3eb434e3df25dd420c98cae5a6d518": {
      "type": "Ybodychange",
      "commitMessage": "type inference\n",
      "commitDate": "2016-10-24, 1:19 p.m.",
      "commitName": "2082034e8c3eb434e3df25dd420c98cae5a6d518",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-23, 5:26 a.m.",
      "commitNameOld": "631896a1d2f34eed89c41cc717f463ebbd69e401",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.33,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 52,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,48 +1,49 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n+                            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot);\n+                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "631896a1d2f34eed89c41cc717f463ebbd69e401": {
      "type": "Ybodychange",
      "commitMessage": "commenting classes in model\n",
      "commitDate": "2016-10-23, 5:26 a.m.",
      "commitName": "631896a1d2f34eed89c41cc717f463ebbd69e401",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-22, 8:39 a.m.",
      "commitNameOld": "dc093e9ac9ae3239375c654c4cfff92ee0fb3927",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,48 +1,48 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                        lambdaType \u003d lambdaType.replaceParam(entry._1, ot);\n+                                        lambdaType \u003d lambdaType.replaceTypeVariables(entry._1, ot);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc093e9ac9ae3239375c654c4cfff92ee0fb3927": {
      "type": "Ybodychange",
      "commitMessage": "more usages of TypeParameterDeclaration instead of just the name\n",
      "commitDate": "2016-10-22, 8:39 a.m.",
      "commitName": "dc093e9ac9ae3239375c654c4cfff92ee0fb3927",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-22, 8:36 a.m.",
      "commitNameOld": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1, ot);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,48 +1,48 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot);\n+                                        lambdaType \u003d lambdaType.replaceParam(entry._1, ot);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6fcf6356a95a250db103245c1c5f2d596f9493d6": {
      "type": "Ybodychange",
      "commitMessage": "model: refactoring\n",
      "commitDate": "2016-10-22, 5:18 a.m.",
      "commitName": "6fcf6356a95a250db103245c1c5f2d596f9493d6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-21, 7:23 a.m.",
      "commitNameOld": "ecc1af475857cf3c62b3a07eb35ad080ed435dea",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot);\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,53 +1,48 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n-                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n-                                        if (ot.isPresent()) {\n-                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n-                                        }\n+                                        Type ot \u003d t.asReferenceType().typeParametersMap().getValue(entry._1);\n+                                        lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n-                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n-                                if (ot.isPresent()) {\n-                                    lambdaType \u003d ot.get();\n-                                }\n+                                lambdaType \u003d t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc1af475857cf3c62b3a07eb35ad080ed435dea": {
      "type": "Ybodychange",
      "commitMessage": "more comments on model\n",
      "commitDate": "2016-10-21, 7:23 a.m.",
      "commitName": "ecc1af475857cf3c62b3a07eb35ad080ed435dea",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-21, 2:55 a.m.",
      "commitNameOld": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,53 +1,53 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n+                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n-                            Value value \u003d new Value(lambdaType, name, false);\n+                            Value value \u003d new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
      "type": "Ybodychange",
      "commitMessage": "adding more comments in model declarations\n",
      "commitDate": "2016-10-21, 2:55 a.m.",
      "commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 4:06 p.m.",
      "commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,53 +1,53 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n-                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n+                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnType()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n-                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n+                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnType()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016-10-20, 2:39 a.m.",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 2:32 a.m.",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 56,
      "functionName": "solveSymbolAsValue",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
      }
    },
    "967b0302143d4d6868c3d9035a8615ccfd198b6e": {
      "type": "Ybodychange",
      "commitMessage": "use VariableDeclarator.getType\n",
      "commitDate": "2016-10-19, 1:36 p.m.",
      "commitName": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:35 p.m.",
      "commitNameOld": "0d14741fef3a17451db153cfe379e398da4b4b79",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 54,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,53 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n-                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n-                        \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n-                        if (getParentNode(variableDeclarator) instanceof VariableDeclarationExpr) {\n-                            declaratorType \u003d ((VariableDeclarationExpr) getParentNode(variableDeclarator)).getElementType();\n-                        } else if (getParentNode(variableDeclarator) instanceof FieldDeclaration) {\n-                            declaratorType \u003d ((FieldDeclaration) getParentNode(variableDeclarator)).getElementType();\n-                        } else {\n-                            throw new UnsupportedOperationException(getParentNode(variableDeclarator).getClass().getCanonicalName());\n-                        }\n-\n-                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                        Type t \u003d JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
      "type": "Ybodychange",
      "commitMessage": "revision of modified code to use Navigator.getParentNode\n",
      "commitDate": "2016-10-19, 1:35 p.m.",
      "commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:34 p.m.",
      "commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n                        if (getParentNode(variableDeclarator) instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) getParentNode(variableDeclarator)).getElementType();\n                        } else if (getParentNode(variableDeclarator) instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) getParentNode(variableDeclarator)).getElementType();\n                        } else {\n                            throw new UnsupportedOperationException(getParentNode(variableDeclarator).getClass().getCanonicalName());\n                        }\n\n                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 56,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n-                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n+                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n+                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n-                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n+                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                         \n-                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n-                        if (variableDeclarator.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n-                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode().getParentNode()).getElementType();\n-                        } else if (variableDeclarator.getParentNode().getParentNode() instanceof FieldDeclaration) {\n-                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode().getParentNode()).getElementType();\n+                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) getParentNode(wrappedNode);\n+                        if (getParentNode(variableDeclarator) instanceof VariableDeclarationExpr) {\n+                            declaratorType \u003d ((VariableDeclarationExpr) getParentNode(variableDeclarator)).getElementType();\n+                        } else if (getParentNode(variableDeclarator) instanceof FieldDeclaration) {\n+                            declaratorType \u003d ((FieldDeclaration) getParentNode(variableDeclarator)).getElementType();\n                         } else {\n-                            throw new UnsupportedOperationException(variableDeclarator.getParentNode().getParentNode().getClass().getCanonicalName());\n+                            throw new UnsupportedOperationException(getParentNode(variableDeclarator).getClass().getCanonicalName());\n                         }\n \n                         Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03e407957d600a18ef0a4a83224c17d155ef8645": {
      "type": "Ybodychange",
      "commitMessage": "fixing a few more tests\n",
      "commitDate": "2016-10-19, 1:34 p.m.",
      "commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:33 p.m.",
      "commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode().getParentNode()).getElementType();\n                        } else if (variableDeclarator.getParentNode().getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode().getParentNode()).getElementType();\n                        } else {\n                            throw new UnsupportedOperationException(variableDeclarator.getParentNode().getParentNode().getClass().getCanonicalName());\n                        }\n\n                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                         \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n-                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n-                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getElementType();\n-                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n-                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getElementType();\n+                        if (variableDeclarator.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n+                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode().getParentNode()).getElementType();\n+                        } else if (variableDeclarator.getParentNode().getParentNode() instanceof FieldDeclaration) {\n+                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode().getParentNode()).getElementType();\n                         } else {\n-                            throw new UnsupportedOperationException();\n+                            throw new UnsupportedOperationException(variableDeclarator.getParentNode().getParentNode().getClass().getCanonicalName());\n                         }\n \n                         Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016-10-19, 1:33 p.m.",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 11:04 a.m.",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getElementType();\n                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getElementType();\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n\n                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 55,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                         \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n-                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n+                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getElementType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n-                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n+                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getElementType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
      "type": "Ybodychange",
      "commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
      "commitDate": "2016-10-14, 4:57 p.m.",
      "commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 1:24 p.m.",
      "commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n\n                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().typeParametersValues().get(0), name, false);\n+                        Value value \u003d new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                         \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n-                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n-                                        Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                        Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n-                                Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                                Optional\u003cType\u003e ot \u003d t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70f3e66c944670a818922f101162226ef604b263": {
      "type": "Ybodychange",
      "commitMessage": "deprecating some methods involving type parameters\n",
      "commitDate": "2016-10-14, 1:24 p.m.",
      "commitName": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 12:51 p.m.",
      "commitNameOld": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().typeParametersValues().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n\n                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n+                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                         \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
      "type": "Ybodychange",
      "commitMessage": "reorganize packages in model\n",
      "commitDate": "2016-10-14, 12:51 p.m.",
      "commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 2:36 a.m.",
      "commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n\n                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                         \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n-                                for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                for (Tuple2\u003cTypeParameterDeclaration, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d234965b572759181da7787fead07b225e9e5ca": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeSolver from MethodUsage\n",
      "commitDate": "2016-10-14, 2:36 a.m.",
      "commitName": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-13, 4:11 p.m.",
      "commitNameOld": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n\n                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                         \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n-                            Type lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n+                            Type lambdaType \u003d functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ybodychange",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016-10-13, 4:11 p.m.",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-12, 5:43 p.m.",
      "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n\n                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            Type lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,63 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n-                        TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n+                        Type lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n-                        Type declaratorType \u003d null;\n+                        com.github.javaparser.ast.type.Type declaratorType \u003d null;\n                         \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n-                        TypeUsage t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                        Type t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n-                            TypeUsage lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n+                            Type lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n-                                for (Tuple2\u003cTypeParameter, TypeUsage\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                for (Tuple2\u003cTypeParameter, Type\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n-                                        Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                        Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n-                                Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                                Optional\u003cType\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType \u003d ot.get();\n                                 }\n                             }\n \n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "401a56f412ca186a00a2282d9088e8cb7b67e0e5": {
      "type": "Ybodychange",
      "commitMessage": "issue80: working on lambdas assigned to variables\n",
      "commitDate": "2016-10-12, 5:43 p.m.",
      "commitName": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-09-23, 10:49 a.m.",
      "commitNameOld": "e529ad59cb7c1766706162cbc3a4fca49cd88e3e",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 19.29,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            int index \u003d 0;\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n\n                        TypeUsage t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n                        if (functionalMethod.isPresent()) {\n                            TypeUsage lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n\n                            // Replace parameter from declarator\n                            if (lambdaType.isReferenceType()) {\n                                for (Tuple2\u003cTypeParameter, TypeUsage\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n                                        Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                        if (ot.isPresent()) {\n                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                        }\n                                    }\n                                }\n                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n                                Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                if (ot.isPresent()) {\n                                    lambdaType \u003d ot.get();\n                                }\n                            }\n\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n                index++;\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 40,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,42 +1,63 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n+            int index \u003d 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i \u003d pos(methodCallExpr, wrappedNode);\n                         TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                         Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         Type declaratorType \u003d null;\n                         \n                         VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n-                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType));\n-                        if (functionalMethod.isPresent() \u0026\u0026 functionalMethod.get().getNoParams() \u003d\u003d 1) {\n-                            TypeUsage lambdaType \u003d functionalMethod.get().getParamType(0, typeSolver);\n+                        TypeUsage t \u003d JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(t);\n+                        if (functionalMethod.isPresent()) {\n+                            TypeUsage lambdaType \u003d functionalMethod.get().getParamType(index, typeSolver);\n+\n+                            // Replace parameter from declarator\n+                            if (lambdaType.isReferenceType()) {\n+                                for (Tuple2\u003cTypeParameter, TypeUsage\u003e entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                    if (entry._2.isTypeVariable() \u0026\u0026 entry._2.asTypeParameter().declaredOnClass()) {\n+                                        Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                        if (ot.isPresent()) {\n+                                            lambdaType \u003d lambdaType.replaceParam(entry._1.getName(), ot.get());\n+                                        }\n+                                    }\n+                                }\n+                            } else if (lambdaType.isTypeVariable() \u0026\u0026 lambdaType.asTypeParameter().declaredOnClass()) {\n+                                Optional\u003cTypeUsage\u003e ot \u003d t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                                if (ot.isPresent()) {\n+                                    lambdaType \u003d ot.get();\n+                                }\n+                            }\n+\n                             Value value \u003d new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n+                index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e529ad59cb7c1766706162cbc3a4fca49cd88e3e": {
      "type": "Ybodychange",
      "commitMessage": "expanded LambdaExprContext to solve lambda parameter types in contexts other than method calls and implemented tests for newly supported cases.\n",
      "commitDate": "2016-09-23, 10:49 a.m.",
      "commitName": "e529ad59cb7c1766706162cbc3a4fca49cd88e3e",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2015-12-03, 3:36 p.m.",
      "commitNameOld": "45898d6dbf0eab3b7258bd74125c70f498fca373",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 294.76,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                if (decl.getName().equals(name)) {\n                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                        int i \u003d pos(methodCallExpr, wrappedNode);\n                        TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                        return Optional.of(value);\n                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                        Type declaratorType \u003d null;\n                        \n                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n\n                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType));\n                        if (functionalMethod.isPresent() \u0026\u0026 functionalMethod.get().getNoParams() \u003d\u003d 1) {\n                            TypeUsage lambdaType \u003d functionalMethod.get().getParamType(0, typeSolver);\n                            Value value \u003d new Value(lambdaType, name, false);\n                            return Optional.of(value);\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n            } \n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 39,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,18 +1,42 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n-            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n-                MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n-                int i \u003d pos(methodCallExpr, wrappedNode);\n-                TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n-                return Optional.of(value);\n-            } else {\n-                throw new UnsupportedOperationException();\n-            }\n+            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n+                if (decl.getName().equals(name)) {\n+                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n+                        MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n+                        MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n+                        int i \u003d pos(methodCallExpr, wrappedNode);\n+                        TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n+                        Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n+                        return Optional.of(value);\n+                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n+                        Type declaratorType \u003d null;\n+                        \n+                        VariableDeclarator variableDeclarator \u003d (VariableDeclarator) wrappedNode.getParentNode();\n+                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n+                            declaratorType \u003d ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n+                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n+                            declaratorType \u003d ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n+\n+                        Optional\u003cMethodUsage\u003e functionalMethod \u003d FunctionalInterfaceLogic.getFunctionalMethod(JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType));\n+                        if (functionalMethod.isPresent() \u0026\u0026 functionalMethod.get().getNoParams() \u003d\u003d 1) {\n+                            TypeUsage lambdaType \u003d functionalMethod.get().getParamType(0, typeSolver);\n+                            Value value \u003d new Value(lambdaType, name, false);\n+                            return Optional.of(value);\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+            } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015-11-22, 5:45 a.m.",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-22, 5:03 a.m.",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                int i \u003d pos(methodCallExpr, wrappedNode);\n                TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                return Optional.of(value);\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
      "functionStartLine": 33,
      "functionName": "solveSymbolAsValue",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
      }
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015-11-13, 4:12 a.m.",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 3:53 a.m.",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr methodCallExpr \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                int i \u003d pos(methodCallExpr, wrappedNode);\n                TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                return Optional.of(value);\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 29,
      "functionName": "solveSymbolAsValue",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java"
      }
    },
    "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeUsage.typeParameters\n",
      "commitDate": "2015-10-30, 11:48 a.m.",
      "commitName": "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 5:53 a.m.",
      "commitNameOld": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n                MethodCallExpr methodCallExpr \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                int i \u003d pos(methodCallExpr, wrappedNode);\n                TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                return Optional.of(value);\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 25,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,18 +1,18 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n                 MethodCallExpr methodCallExpr \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                 MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                 int i \u003d pos(methodCallExpr, wrappedNode);\n                 TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n-                Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n+                Value value \u003d new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                 return Optional.of(value);\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36f33050149a62a5b3c8c7451ae93f736715029": {
      "type": "Yfilerename",
      "commitMessage": "reorganize packages\n",
      "commitDate": "2015-10-30, 5:53 a.m.",
      "commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 5:29 a.m.",
      "commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n                MethodCallExpr methodCallExpr \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                int i \u003d pos(methodCallExpr, wrappedNode);\n                TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n                return Optional.of(value);\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 25,
      "functionName": "solveSymbolAsValue",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/LambdaExprContext.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java"
      }
    },
    "627b56302d259409e9bc50b20d77803484f18b5c": {
      "type": "Ybodychange",
      "commitMessage": "introduce cache in JavaParserFacade\n",
      "commitDate": "2015-08-05, 10:25 a.m.",
      "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-05, 10:08 a.m.",
      "commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n                MethodCallExpr methodCallExpr \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                int i \u003d pos(methodCallExpr, wrappedNode);\n                TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n                return Optional.of(value);\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 24,
      "functionName": "solveSymbolAsValue",
      "diff": "@@ -1,18 +1,18 @@\n     public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n                 MethodCallExpr methodCallExpr \u003d (MethodCallExpr)wrappedNode.getParentNode();\n-                MethodUsage methodUsage \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n+                MethodUsage methodUsage \u003d JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                 int i \u003d pos(methodCallExpr, wrappedNode);\n                 TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                 Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n                 return Optional.of(value);\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1adb8b4c97103ac5b15d009f3eda791a53b83d6f": {
      "type": "Yintroduced",
      "commitMessage": "add resolveReferenceToLambdaParamBase\n",
      "commitDate": "2015-08-05, 10:08 a.m.",
      "commitName": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,18 @@\n+    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n+        for (Parameter parameter : wrappedNode.getParameters()) {\n+            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n+            if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n+                MethodCallExpr methodCallExpr \u003d (MethodCallExpr)wrappedNode.getParentNode();\n+                MethodUsage methodUsage \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n+                int i \u003d pos(methodCallExpr, wrappedNode);\n+                TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n+                Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n+                return Optional.of(value);\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        // if nothing is found we should ask the parent context\n+        return getParent().solveSymbolAsValue(name, typeSolver);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public Optional\u003cValue\u003e solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        for (Parameter parameter : wrappedNode.getParameters()) {\n            SymbolDeclarator sb \u003d JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n                MethodCallExpr methodCallExpr \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                MethodUsage methodUsage \u003d new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n                int i \u003d pos(methodCallExpr, wrappedNode);\n                TypeUsage lambdaType \u003d methodUsage.getParamTypes().get(i);\n                Value value \u003d new Value(lambdaType.parameters().get(0), name, false);\n                return Optional.of(value);\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        }\n\n        // if nothing is found we should ask the parent context\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/LambdaExprContext.java",
      "functionStartLine": 24,
      "functionName": "solveSymbolAsValue"
    }
  }
}