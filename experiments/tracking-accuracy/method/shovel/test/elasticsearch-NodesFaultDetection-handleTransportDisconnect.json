{
  "origin": "codeshovel",
  "repositoryName": "elasticsearch",
  "repositoryPath": "H:\\Projects\\elastic\\elasticsearch/.git",
  "startCommitName": "767c69593c67befb843686de8ea51b7bc87728c9",
  "sourceFileName": "NodesFaultDetection.java",
  "functionName": "handleTransportDisconnect",
  "functionId": "handleTransportDisconnect___node-DiscoveryNode",
  "sourceFilePath": "server/src/main/java/org/elasticsearch/discovery/zen/NodesFaultDetection.java",
  "functionStartLine": 149,
  "functionEndLine": 171,
  "numCommitsSeen": 78,
  "timeTaken": 6678,
  "changeHistory": [
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
    "53cff0f00ff767d028d654ec75c12bc8ff16206b",
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
    "36c3e896de86ced11a239e9b0ce66a896d472a8a",
    "596a4a073584c4262d574828c9caea35b5ed1de5",
    "5302a53145a62ec2add7bdab095a92074819266a",
    "caf11ff2fbd9195cc780edb375f6a74302d906df",
    "ae16956e072bea317ea481f65f2e110dc48fde17",
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c",
    "3ed848a495a494538a9071ccd447f23fa07fb7f2",
    "ccb30d42e9512c2618880a3cd026d6c6c2e5a253",
    "de7dd3c0706c21b2ae5d12e266d662a8fb989784",
    "86134d32a806b657b9db2a7ceb5dbd6d3b0f234d",
    "a59679b0c678e0d614953baef20237578b506f08",
    "b4940d258cc16193df07a2b57da83bb3d753cff5",
    "cb0d7d4735665fa8ca1b59555a06354859c0045a"
  ],
  "changeHistoryShort": {
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": "Yfilerename",
    "53cff0f00ff767d028d654ec75c12bc8ff16206b": "Yfilerename",
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5": "Yfilerename",
    "36c3e896de86ced11a239e9b0ce66a896d472a8a": "Ybodychange",
    "596a4a073584c4262d574828c9caea35b5ed1de5": "Ymodifierchange",
    "5302a53145a62ec2add7bdab095a92074819266a": "Ybodychange",
    "caf11ff2fbd9195cc780edb375f6a74302d906df": "Ybodychange",
    "ae16956e072bea317ea481f65f2e110dc48fde17": "Ybodychange",
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c": "Yfilerename",
    "3ed848a495a494538a9071ccd447f23fa07fb7f2": "Ybodychange",
    "ccb30d42e9512c2618880a3cd026d6c6c2e5a253": "Ybodychange",
    "de7dd3c0706c21b2ae5d12e266d662a8fb989784": "Ybodychange",
    "86134d32a806b657b9db2a7ceb5dbd6d3b0f234d": "Ybodychange",
    "a59679b0c678e0d614953baef20237578b506f08": "Ybodychange",
    "b4940d258cc16193df07a2b57da83bb3d753cff5": "Ybodychange",
    "cb0d7d4735665fa8ca1b59555a06354859c0045a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": {
      "type": "Yfilerename",
      "commitMessage": "Rename core module to server (#28180)\n\nThis is related to #27933. It renames the core module to server. This is\r\nthe first step towards introducing an elasticsearch-core jar.",
      "commitDate": "2018-01-11, 1:30 p.m.",
      "commitName": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
      "commitAuthor": "Tim Brooks",
      "commitDateOld": "2018-01-11, 11:31 a.m.",
      "commitNameOld": "7d0eb3292b8f8ba27ef50dbbf38783dc68c70728",
      "commitAuthorOld": "Martijn van Groningen",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected void handleTransportDisconnect(DiscoveryNode node) {\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (connectOnNetworkDisconnect) {\n            NodeFD fd \u003d new NodeFD(node);\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, fd);\n                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                // clean up if needed, just to be safe..\n                nodesFD.remove(node, fd);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "server/src/main/java/org/elasticsearch/discovery/zen/NodesFaultDetection.java",
      "functionStartLine": 145,
      "functionName": "handleTransportDisconnect",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/elasticsearch/discovery/zen/NodesFaultDetection.java",
        "newPath": "server/src/main/java/org/elasticsearch/discovery/zen/NodesFaultDetection.java"
      }
    },
    "53cff0f00ff767d028d654ec75c12bc8ff16206b": {
      "type": "Yfilerename",
      "commitMessage": "Move all zen discovery classes into o.e.discovery.zen (#21032)\n\n* Move all zen discovery classes into o.e.discovery.zen\r\n\r\nThis collapses sub packages of zen into zen. These all had just a couple\r\nclasses each, and there is really no reason to have the subpackages.\r\n\r\n* fix checkstyle\r\n",
      "commitDate": "2016-10-20, 3:44 a.m.",
      "commitName": "53cff0f00ff767d028d654ec75c12bc8ff16206b",
      "commitAuthor": "Ryan Ernst",
      "commitDateOld": "2016-10-20, 3:26 a.m.",
      "commitNameOld": "95b6f85c87d301f2038711d094752c1c5dac443f",
      "commitAuthorOld": "qwerty4030",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected void handleTransportDisconnect(DiscoveryNode node) {\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (connectOnNetworkDisconnect) {\n            NodeFD fd \u003d new NodeFD(node);\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, fd);\n                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                // clean up if needed, just to be safe..\n                nodesFD.remove(node, fd);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "core/src/main/java/org/elasticsearch/discovery/zen/NodesFaultDetection.java",
      "functionStartLine": 145,
      "functionName": "handleTransportDisconnect",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
        "newPath": "core/src/main/java/org/elasticsearch/discovery/zen/NodesFaultDetection.java"
      }
    },
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5": {
      "type": "Yfilerename",
      "commitMessage": "create core module\n",
      "commitDate": "2015-06-05, 7:12 a.m.",
      "commitName": "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2015-06-05, 7:11 a.m.",
      "commitNameOld": "7ccc193a666e2ae888e7ac93d677a2143e5e07c3",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected void handleTransportDisconnect(DiscoveryNode node) {\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (connectOnNetworkDisconnect) {\n            NodeFD fd \u003d new NodeFD(node);\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, fd);\n                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                // clean up if needed, just to be safe..\n                nodesFD.remove(node, fd);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "core/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 124,
      "functionName": "handleTransportDisconnect",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
        "newPath": "core/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java"
      }
    },
    "36c3e896de86ced11a239e9b0ce66a896d472a8a": {
      "type": "Ybodychange",
      "commitMessage": "NodesFD: simplify concurrency control to fully rely on a single map\n\nThe node fault detection class is used by the master node to ping the nodes in the cluster and verify they are alive. This PR simplifies the concurrency controls in the class + adds a test for a scenario that surfaced the problem.\n\nCloses #7889\n",
      "commitDate": "2014-09-26, 5:21 a.m.",
      "commitName": "36c3e896de86ced11a239e9b0ce66a896d472a8a",
      "commitAuthor": "Boaz Leskes",
      "commitDateOld": "2014-09-26, 5:21 a.m.",
      "commitNameOld": "db54e9c2d5d5fc3405cf29a4f92ef56ccc17b4dd",
      "commitAuthorOld": "Boaz Leskes",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected void handleTransportDisconnect(DiscoveryNode node) {\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (connectOnNetworkDisconnect) {\n            NodeFD fd \u003d new NodeFD(node);\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, fd);\n                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                // clean up if needed, just to be safe..\n                nodesFD.remove(node, fd);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 125,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,27 +1,23 @@\n     protected void handleTransportDisconnect(DiscoveryNode node) {\n-        if (!latestNodes.nodeExists(node.id())) {\n-            return;\n-        }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n-        if (!running) {\n-            return;\n-        }\n-        nodeFD.running \u003d false;\n         if (connectOnNetworkDisconnect) {\n+            NodeFD fd \u003d new NodeFD(node);\n             try {\n                 transportService.connectToNode(node);\n-                nodesFD.put(node, new NodeFD());\n+                nodesFD.put(node, fd);\n                 // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n-                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, new SendPingRequest(node));\n+                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);\n             } catch (Exception e) {\n                 logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n+                // clean up if needed, just to be safe..\n+                nodesFD.remove(node, fd);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "596a4a073584c4262d574828c9caea35b5ed1de5": {
      "type": "Ymodifierchange",
      "commitMessage": "[Internal] Extract a common base class for (Master|Nodes)FaultDetection\n\nThey share a lot of settings and some logic.\n\nCloses #7512\n",
      "commitDate": "2014-09-01, 9:51 a.m.",
      "commitName": "596a4a073584c4262d574828c9caea35b5ed1de5",
      "commitAuthor": "Boaz Leskes",
      "commitDateOld": "2014-08-29, 4:57 p.m.",
      "commitNameOld": "d8a5ff0047f530f489b34702a61e85037ce2e7b6",
      "commitAuthorOld": "Boaz Leskes",
      "daysBetweenCommits": 2.7,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    protected void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        nodeFD.running \u003d false;\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, new NodeFD());\n                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, new SendPingRequest(node));\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 131,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,27 +1,27 @@\n-    private void handleTransportDisconnect(DiscoveryNode node) {\n+    protected void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         nodeFD.running \u003d false;\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n                 nodesFD.put(node, new NodeFD());\n                 // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n                 threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, new SendPingRequest(node));\n             } catch (Exception e) {\n                 logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[protected]"
      }
    },
    "5302a53145a62ec2add7bdab095a92074819266a": {
      "type": "Ybodychange",
      "commitMessage": "[Discovery] immediately start Master|Node fault detection pinging\n\nAfter a node joins the clusters, it starts pinging the master to verify it\u0027s health. Before, the cluster join request was processed async and we had to give some time to complete. With  #6480 we changed this to wait for the join process to complete on the master. We can therefore start pinging immediately for fast detection of failures. Similar change can be made to the Node fault detection from the master side.\n\nCloses #6706\n",
      "commitDate": "2014-08-27, 9:47 a.m.",
      "commitName": "5302a53145a62ec2add7bdab095a92074819266a",
      "commitAuthor": "Boaz Leskes",
      "commitDateOld": "2014-08-27, 9:47 a.m.",
      "commitNameOld": "7db9e98ee77e50c9e0b8b8f859a00263903a1980",
      "commitAuthorOld": "Boaz Leskes",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        nodeFD.running \u003d false;\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, new NodeFD());\n                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, new SendPingRequest(node));\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 155,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,26 +1,27 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         nodeFD.running \u003d false;\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n                 nodesFD.put(node, new NodeFD());\n-                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, new SendPingRequest(node));\n+                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n+                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, new SendPingRequest(node));\n             } catch (Exception e) {\n                 logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "caf11ff2fbd9195cc780edb375f6a74302d906df": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"[Discovery] immediately start Master|Node fault detection pinging\"\n\nIn #6706 we change the master validation to start pining immediately after a new master as ellected or a node joined. The idea is to have a quicker response to failures. This does however create a problem if the new master has yet fully processed it\u0027s ellection and responds to the ping with a NoLongerMasterException. This causes the source node to remove the current master and ellect another, only to find out it\u0027s not a master either and so forth. We are moving this change to the feature/improve_zen branch, where the improvements we made will cause the situation to be handled properly.\n\nThis reverts commit ae16956e072bea317ea481f65f2e110dc48fde17.\n",
      "commitDate": "2014-07-08, 7:35 a.m.",
      "commitName": "caf11ff2fbd9195cc780edb375f6a74302d906df",
      "commitAuthor": "Boaz Leskes",
      "commitDateOld": "2014-07-03, 8:51 a.m.",
      "commitNameOld": "ae16956e072bea317ea481f65f2e110dc48fde17",
      "commitAuthorOld": "Boaz Leskes",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        nodeFD.running \u003d false;\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, new NodeFD());\n                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, new SendPingRequest(node));\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 152,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,27 +1,26 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         nodeFD.running \u003d false;\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n                 nodesFD.put(node, new NodeFD());\n-                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n-                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, new SendPingRequest(node));\n+                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, new SendPingRequest(node));\n             } catch (Exception e) {\n                 logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ae16956e072bea317ea481f65f2e110dc48fde17": {
      "type": "Ybodychange",
      "commitMessage": "[Discovery] immediately start Master|Node fault detection pinging\n\nAfter a node joins the clusters, it starts pinging the master to verify it\u0027s health. Before, the cluster join request was processed async and we had to give some time to complete. With  #6480 we changed this to wait for the join process to complete on the master. We can therefore start pinging immediately for fast detection of failures. Similar change can be made to the Node fault detection from the master side.\n\nCloses #6706\n",
      "commitDate": "2014-07-03, 8:51 a.m.",
      "commitName": "ae16956e072bea317ea481f65f2e110dc48fde17",
      "commitAuthor": "Boaz Leskes",
      "commitDateOld": "2014-07-03, 7:42 a.m.",
      "commitNameOld": "7beac4ddbfabc2e2cecc06708dc48783aed4b2a1",
      "commitAuthorOld": "Boaz Leskes",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        nodeFD.running \u003d false;\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, new NodeFD());\n                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, new SendPingRequest(node));\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 153,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,26 +1,27 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         nodeFD.running \u003d false;\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n                 nodesFD.put(node, new NodeFD());\n-                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, new SendPingRequest(node));\n+                // we use schedule with a 0 time value to run the pinger on the pool as it will run on later\n+                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, new SendPingRequest(node));\n             } catch (Exception e) {\n                 logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c": {
      "type": "Yfilerename",
      "commitMessage": "first cleanup phase, move to single src\n",
      "commitDate": "2011-12-05, 5:59 p.m.",
      "commitName": "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c",
      "commitAuthor": "Shay Banon",
      "commitDateOld": "2011-12-05, 2:00 p.m.",
      "commitNameOld": "473b0f4dff504690754acc0f00967c275bf322a8",
      "commitAuthorOld": "Shay Banon",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        nodeFD.running \u003d false;\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, new NodeFD());\n                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, new SendPingRequest(node));\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 155,
      "functionName": "handleTransportDisconnect",
      "diff": "",
      "extendedDetails": {
        "oldPath": "modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
        "newPath": "src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java"
      }
    },
    "3ed848a495a494538a9071ccd447f23fa07fb7f2": {
      "type": "Ybodychange",
      "commitMessage": "ThreadPool: Refactor into several pools, with configurable types per pool, closes #687.\n",
      "commitDate": "2011-02-15, 12:00 a.m.",
      "commitName": "3ed848a495a494538a9071ccd447f23fa07fb7f2",
      "commitAuthor": "kimchy",
      "commitDateOld": "2011-02-09, 9:25 a.m.",
      "commitNameOld": "ccb30d42e9512c2618880a3cd026d6c6c2e5a253",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 5.61,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        nodeFD.running \u003d false;\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, new NodeFD());\n                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, new SendPingRequest(node));\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 155,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,26 +1,26 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         nodeFD.running \u003d false;\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n                 nodesFD.put(node, new NodeFD());\n-                threadPool.schedule(new SendPingRequest(node), pingInterval, ThreadPool.ExecutionType.DEFAULT);\n+                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, new SendPingRequest(node));\n             } catch (Exception e) {\n                 logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ccb30d42e9512c2618880a3cd026d6c6c2e5a253": {
      "type": "Ybodychange",
      "commitMessage": "move to use a single thread for the scheduled tasks, forking where need to another TP\n",
      "commitDate": "2011-02-09, 9:25 a.m.",
      "commitName": "ccb30d42e9512c2618880a3cd026d6c6c2e5a253",
      "commitAuthor": "kimchy",
      "commitDateOld": "2010-12-23, 9:51 a.m.",
      "commitNameOld": "de7dd3c0706c21b2ae5d12e266d662a8fb989784",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 47.98,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        nodeFD.running \u003d false;\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, new NodeFD());\n                threadPool.schedule(new SendPingRequest(node), pingInterval, ThreadPool.ExecutionType.DEFAULT);\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 155,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,26 +1,26 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         nodeFD.running \u003d false;\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n                 nodesFD.put(node, new NodeFD());\n-                threadPool.schedule(new SendPingRequest(node), pingInterval);\n+                threadPool.schedule(new SendPingRequest(node), pingInterval, ThreadPool.ExecutionType.DEFAULT);\n             } catch (Exception e) {\n                 logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de7dd3c0706c21b2ae5d12e266d662a8fb989784": {
      "type": "Ybodychange",
      "commitMessage": "default to try and connect after network disconnection with fault detection\n",
      "commitDate": "2010-12-23, 9:51 a.m.",
      "commitName": "de7dd3c0706c21b2ae5d12e266d662a8fb989784",
      "commitAuthor": "kimchy",
      "commitDateOld": "2010-12-15, 1:11 p.m.",
      "commitNameOld": "d6bab1a892cbfdfaa46d8d0657ac0028255866b2",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 7.86,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        nodeFD.running \u003d false;\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n                nodesFD.put(node, new NodeFD());\n                threadPool.schedule(new SendPingRequest(node), pingInterval);\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 155,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,23 +1,26 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n+        nodeFD.running \u003d false;\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n+                nodesFD.put(node, new NodeFD());\n+                threadPool.schedule(new SendPingRequest(node), pingInterval);\n             } catch (Exception e) {\n                 logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "86134d32a806b657b9db2a7ceb5dbd6d3b0f234d": {
      "type": "Ybodychange",
      "commitMessage": "nicer logging\n",
      "commitDate": "2010-06-17, 5:46 a.m.",
      "commitName": "86134d32a806b657b9db2a7ceb5dbd6d3b0f234d",
      "commitAuthor": "kimchy",
      "commitDateOld": "2010-06-16, 6:05 p.m.",
      "commitNameOld": "8af925a0b15b9a1d348170417ac9e787dfff8c86",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n            } catch (Exception e) {\n                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 154,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,23 +1,23 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n             } catch (Exception e) {\n-                logger.trace(\"Node [{}] transport disconnected (with verified connect)\", node);\n+                logger.trace(\"[node  ] [{}] transport disconnected (with verified connect)\", node);\n                 notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n-            logger.trace(\"Node [{}] transport disconnected\", node);\n+            logger.trace(\"[node  ] [{}] transport disconnected\", node);\n             notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a59679b0c678e0d614953baef20237578b506f08": {
      "type": "Ybodychange",
      "commitMessage": "better failure messages\n",
      "commitDate": "2010-06-16, 2:47 p.m.",
      "commitName": "a59679b0c678e0d614953baef20237578b506f08",
      "commitAuthor": "kimchy",
      "commitDateOld": "2010-06-15, 4:14 p.m.",
      "commitNameOld": "8e589b5a04d14b4847b1bd06c6ceb8f8e9f606df",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n            } catch (Exception e) {\n                logger.trace(\"Node [{}] transport disconnected (with verified connect)\", node);\n                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"Node [{}] transport disconnected\", node);\n            notifyNodeFailure(node, \"transport disconnected\");\n        }\n    }",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 148,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,23 +1,23 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n             } catch (Exception e) {\n-                logger.trace(\"Node [{}] failed on disconnect (with verified connect)\", node);\n-                notifyNodeFailure(node, \"Failed on disconnect (with verified connect)\");\n+                logger.trace(\"Node [{}] transport disconnected (with verified connect)\", node);\n+                notifyNodeFailure(node, \"transport disconnected (with verified connect)\");\n             }\n         } else {\n-            logger.trace(\"Node [{}] failed on disconnect\", node);\n-            notifyNodeFailure(node, \"Failed on disconnect\");\n+            logger.trace(\"Node [{}] transport disconnected\", node);\n+            notifyNodeFailure(node, \"transport disconnected\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4940d258cc16193df07a2b57da83bb3d753cff5": {
      "type": "Ybodychange",
      "commitMessage": "fix FD with zen discovery to actually retry and not rely on closed socket\n",
      "commitDate": "2010-05-20, 3:05 p.m.",
      "commitName": "b4940d258cc16193df07a2b57da83bb3d753cff5",
      "commitAuthor": "kimchy",
      "commitDateOld": "2010-05-16, 4:40 p.m.",
      "commitNameOld": "ab57fa86af5698d60c4021d247994af64344a753",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 3.93,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n            } catch (Exception e) {\n                logger.trace(\"Node [{}] failed on disconnect (with verified connect)\", node);\n                notifyNodeFailure(node, \"Failed on disconnect (with verified connect)\");\n            }\n        } else {\n            logger.trace(\"Node [{}] failed on disconnect\", node);\n            notifyNodeFailure(node, \"Failed on disconnect\");\n        }\n    }",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 147,
      "functionName": "handleTransportDisconnect",
      "diff": "@@ -1,23 +1,23 @@\n     private void handleTransportDisconnect(DiscoveryNode node) {\n         if (!latestNodes.nodeExists(node.id())) {\n             return;\n         }\n         NodeFD nodeFD \u003d nodesFD.remove(node);\n         if (nodeFD \u003d\u003d null) {\n             return;\n         }\n         if (!running) {\n             return;\n         }\n         if (connectOnNetworkDisconnect) {\n             try {\n                 transportService.connectToNode(node);\n             } catch (Exception e) {\n                 logger.trace(\"Node [{}] failed on disconnect (with verified connect)\", node);\n-                notifyNodeFailure(node);\n+                notifyNodeFailure(node, \"Failed on disconnect (with verified connect)\");\n             }\n         } else {\n             logger.trace(\"Node [{}] failed on disconnect\", node);\n-            notifyNodeFailure(node);\n+            notifyNodeFailure(node, \"Failed on disconnect\");\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cb0d7d4735665fa8ca1b59555a06354859c0045a": {
      "type": "Yintroduced",
      "commitMessage": "inital support for zen discovery module (multicast discovery implemented)\n",
      "commitDate": "2010-04-24, 4:48 p.m.",
      "commitName": "cb0d7d4735665fa8ca1b59555a06354859c0045a",
      "commitAuthor": "kimchy",
      "diff": "@@ -0,0 +1,23 @@\n+    private void handleTransportDisconnect(DiscoveryNode node) {\n+        if (!latestNodes.nodeExists(node.id())) {\n+            return;\n+        }\n+        NodeFD nodeFD \u003d nodesFD.remove(node);\n+        if (nodeFD \u003d\u003d null) {\n+            return;\n+        }\n+        if (!running) {\n+            return;\n+        }\n+        if (connectOnNetworkDisconnect) {\n+            try {\n+                transportService.connectToNode(node);\n+            } catch (Exception e) {\n+                logger.trace(\"Node [{}] failed on disconnect (with verified connect)\", node);\n+                notifyNodeFailure(node);\n+            }\n+        } else {\n+            logger.trace(\"Node [{}] failed on disconnect\", node);\n+            notifyNodeFailure(node);\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void handleTransportDisconnect(DiscoveryNode node) {\n        if (!latestNodes.nodeExists(node.id())) {\n            return;\n        }\n        NodeFD nodeFD \u003d nodesFD.remove(node);\n        if (nodeFD \u003d\u003d null) {\n            return;\n        }\n        if (!running) {\n            return;\n        }\n        if (connectOnNetworkDisconnect) {\n            try {\n                transportService.connectToNode(node);\n            } catch (Exception e) {\n                logger.trace(\"Node [{}] failed on disconnect (with verified connect)\", node);\n                notifyNodeFailure(node);\n            }\n        } else {\n            logger.trace(\"Node [{}] failed on disconnect\", node);\n            notifyNodeFailure(node);\n        }\n    }",
      "path": "modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java",
      "functionStartLine": 139,
      "functionName": "handleTransportDisconnect"
    }
  }
}