{
  "origin": "codeshovel",
  "repositoryName": "jetty.project",
  "repositoryPath": "H:\\Projects\\eclipse\\jetty.project/.git",
  "startCommitName": "fc5dd874f3deda71e6cd42af994a5af5cb6be4af",
  "sourceFileName": "JsrSession.java",
  "functionName": "addMessageHandler",
  "functionId": "addMessageHandler___handler-MessageHandler",
  "sourceFilePath": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
  "functionStartLine": 95,
  "functionEndLine": 142,
  "numCommitsSeen": 47,
  "timeTaken": 2133,
  "changeHistory": [
    "05c534275253ba65a23863b5ef976636fcd8da4c",
    "33c11dffaa86d09b33fd350f07cd9c548b7d3b7c",
    "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
    "d1692733f56b7c67a885b8c9fdd14fa204c8cab6",
    "3a66b3ec3f8d608140be000dbec507ffd55a503b",
    "43231d84510fde66c4a19a5aac4782eaef15de16"
  ],
  "changeHistoryShort": {
    "05c534275253ba65a23863b5ef976636fcd8da4c": "Ybodychange",
    "33c11dffaa86d09b33fd350f07cd9c548b7d3b7c": "Ybodychange",
    "46e9493c850d0ff2e6f30f455ad358251e1a2d48": "Ymultichange(Yparameterchange,Ybodychange)",
    "d1692733f56b7c67a885b8c9fdd14fa204c8cab6": "Ybodychange",
    "3a66b3ec3f8d608140be000dbec507ffd55a503b": "Ybodychange",
    "43231d84510fde66c4a19a5aac4782eaef15de16": "Yintroduced"
  },
  "changeHistoryDetails": {
    "05c534275253ba65a23863b5ef976636fcd8da4c": {
      "type": "Ybodychange",
      "commitMessage": "JSR-356 Improving MessageHandler manipulation\n",
      "commitDate": "2013-07-15, 7:00 p.m.",
      "commitName": "05c534275253ba65a23863b5ef976636fcd8da4c",
      "commitAuthor": "Joakim Erdfelt",
      "commitDateOld": "2013-07-15, 2:49 p.m.",
      "commitNameOld": "179a78e5028b77880d96e512a7b04b39e1ef694e",
      "commitAuthorOld": "Joakim Erdfelt",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void addMessageHandler(MessageHandler handler) throws IllegalStateException\n    {\n        Objects.requireNonNull(handler,\"MessageHandler cannot be null\");\n\n        synchronized (wrappers)\n        {\n            for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass()))\n            {\n                DecoderFactory.Wrapper wrapper \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n                if (wrapper \u003d\u003d null)\n                {\n                    StringBuilder err \u003d new StringBuilder();\n                    err.append(\"Unable to find decoder for type \u003c\");\n                    err.append(metadata.getMessageClass().getName());\n                    err.append(\"\u003e used in \u003c\");\n                    err.append(metadata.getHandlerClass().getName());\n                    err.append(\"\u003e\");\n                    throw new IllegalStateException(err.toString());\n                }\n\n                MessageType key \u003d wrapper.getMetadata().getMessageType();\n                MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n                if (other !\u003d null)\n                {\n                    StringBuilder err \u003d new StringBuilder();\n                    err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                    err.append(wrapper.getMetadata().getObjectType().getName());\n                    err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                    err.append(\"\u003c\");\n                    err.append(metadata.getMessageClass().getName());\n                    err.append(\"\u003e and \");\n                    err.append(other.getMetadata().getHandlerClass().getName());\n                    err.append(\"\u003c\");\n                    err.append(other.getMetadata().getMessageClass().getName());\n                    err.append(\"\u003e both implement this message type\");\n                    throw new IllegalStateException(err.toString());\n                }\n                else\n                {\n                    MessageHandlerWrapper handlerWrapper \u003d new MessageHandlerWrapper(handler,metadata,wrapper);\n                    wrappers[key.ordinal()] \u003d handlerWrapper;\n                }\n            }\n\n            // Update handlerSet\n            updateMessageHandlerSet();\n        }\n    }",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 96,
      "functionName": "addMessageHandler",
      "diff": "@@ -1,57 +1,48 @@\n     public void addMessageHandler(MessageHandler handler) throws IllegalStateException\n     {\n         Objects.requireNonNull(handler,\"MessageHandler cannot be null\");\n \n         synchronized (wrappers)\n         {\n             for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass()))\n             {\n                 DecoderFactory.Wrapper wrapper \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n                 if (wrapper \u003d\u003d null)\n                 {\n                     StringBuilder err \u003d new StringBuilder();\n                     err.append(\"Unable to find decoder for type \u003c\");\n                     err.append(metadata.getMessageClass().getName());\n                     err.append(\"\u003e used in \u003c\");\n                     err.append(metadata.getHandlerClass().getName());\n                     err.append(\"\u003e\");\n                     throw new IllegalStateException(err.toString());\n                 }\n \n                 MessageType key \u003d wrapper.getMetadata().getMessageType();\n                 MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n                 if (other !\u003d null)\n                 {\n                     StringBuilder err \u003d new StringBuilder();\n                     err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n-                    err.append(key.name());\n+                    err.append(wrapper.getMetadata().getObjectType().getName());\n                     err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                     err.append(\"\u003c\");\n                     err.append(metadata.getMessageClass().getName());\n                     err.append(\"\u003e and \");\n                     err.append(other.getMetadata().getHandlerClass().getName());\n                     err.append(\"\u003c\");\n                     err.append(other.getMetadata().getMessageClass().getName());\n                     err.append(\"\u003e both implement this message type\");\n                     throw new IllegalStateException(err.toString());\n                 }\n                 else\n                 {\n                     MessageHandlerWrapper handlerWrapper \u003d new MessageHandlerWrapper(handler,metadata,wrapper);\n                     wrappers[key.ordinal()] \u003d handlerWrapper;\n                 }\n             }\n \n             // Update handlerSet\n-            messageHandlerSet.clear();\n-            for (MessageHandlerWrapper wrapper : wrappers)\n-            {\n-                if (wrapper \u003d\u003d null)\n-                {\n-                    // skip empty\n-                    continue;\n-                }\n-                messageHandlerSet.add(wrapper.getHandler());\n-            }\n+            updateMessageHandlerSet();\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "33c11dffaa86d09b33fd350f07cd9c548b7d3b7c": {
      "type": "Ybodychange",
      "commitMessage": "JSR-356 - cleaning up Decoder and Encoder lifecycle.\n",
      "commitDate": "2013-07-09, 5:16 p.m.",
      "commitName": "33c11dffaa86d09b33fd350f07cd9c548b7d3b7c",
      "commitAuthor": "Joakim Erdfelt",
      "commitDateOld": "2013-07-09, 5:16 p.m.",
      "commitNameOld": "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
      "commitAuthorOld": "Joakim Erdfelt",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void addMessageHandler(MessageHandler handler) throws IllegalStateException\n    {\n        Objects.requireNonNull(handler,\"MessageHandler cannot be null\");\n\n        synchronized (wrappers)\n        {\n            for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass()))\n            {\n                DecoderFactory.Wrapper wrapper \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n                if (wrapper \u003d\u003d null)\n                {\n                    StringBuilder err \u003d new StringBuilder();\n                    err.append(\"Unable to find decoder for type \u003c\");\n                    err.append(metadata.getMessageClass().getName());\n                    err.append(\"\u003e used in \u003c\");\n                    err.append(metadata.getHandlerClass().getName());\n                    err.append(\"\u003e\");\n                    throw new IllegalStateException(err.toString());\n                }\n\n                MessageType key \u003d wrapper.getMetadata().getMessageType();\n                MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n                if (other !\u003d null)\n                {\n                    StringBuilder err \u003d new StringBuilder();\n                    err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                    err.append(key.name());\n                    err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                    err.append(\"\u003c\");\n                    err.append(metadata.getMessageClass().getName());\n                    err.append(\"\u003e and \");\n                    err.append(other.getMetadata().getHandlerClass().getName());\n                    err.append(\"\u003c\");\n                    err.append(other.getMetadata().getMessageClass().getName());\n                    err.append(\"\u003e both implement this message type\");\n                    throw new IllegalStateException(err.toString());\n                }\n                else\n                {\n                    MessageHandlerWrapper handlerWrapper \u003d new MessageHandlerWrapper(handler,metadata,wrapper);\n                    wrappers[key.ordinal()] \u003d handlerWrapper;\n                }\n            }\n\n            // Update handlerSet\n            messageHandlerSet.clear();\n            for (MessageHandlerWrapper wrapper : wrappers)\n            {\n                if (wrapper \u003d\u003d null)\n                {\n                    // skip empty\n                    continue;\n                }\n                messageHandlerSet.add(wrapper.getHandler());\n            }\n        }\n    }",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 96,
      "functionName": "addMessageHandler",
      "diff": "@@ -1,46 +1,57 @@\n     public void addMessageHandler(MessageHandler handler) throws IllegalStateException\n     {\n         Objects.requireNonNull(handler,\"MessageHandler cannot be null\");\n \n         synchronized (wrappers)\n         {\n             for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass()))\n             {\n-                DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n-                MessageType key \u003d decoder.getMetadata().getMessageType();\n+                DecoderFactory.Wrapper wrapper \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n+                if (wrapper \u003d\u003d null)\n+                {\n+                    StringBuilder err \u003d new StringBuilder();\n+                    err.append(\"Unable to find decoder for type \u003c\");\n+                    err.append(metadata.getMessageClass().getName());\n+                    err.append(\"\u003e used in \u003c\");\n+                    err.append(metadata.getHandlerClass().getName());\n+                    err.append(\"\u003e\");\n+                    throw new IllegalStateException(err.toString());\n+                }\n+\n+                MessageType key \u003d wrapper.getMetadata().getMessageType();\n                 MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n                 if (other !\u003d null)\n                 {\n                     StringBuilder err \u003d new StringBuilder();\n                     err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                     err.append(key.name());\n                     err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                     err.append(\"\u003c\");\n                     err.append(metadata.getMessageClass().getName());\n                     err.append(\"\u003e and \");\n                     err.append(other.getMetadata().getHandlerClass().getName());\n                     err.append(\"\u003c\");\n                     err.append(other.getMetadata().getMessageClass().getName());\n                     err.append(\"\u003e both implement this message type\");\n                     throw new IllegalStateException(err.toString());\n                 }\n                 else\n                 {\n-                    MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler,metadata,decoder);\n-                    wrappers[key.ordinal()] \u003d wrapper;\n+                    MessageHandlerWrapper handlerWrapper \u003d new MessageHandlerWrapper(handler,metadata,wrapper);\n+                    wrappers[key.ordinal()] \u003d handlerWrapper;\n                 }\n             }\n \n             // Update handlerSet\n             messageHandlerSet.clear();\n             for (MessageHandlerWrapper wrapper : wrappers)\n             {\n                 if (wrapper \u003d\u003d null)\n                 {\n                     // skip empty\n                     continue;\n                 }\n                 messageHandlerSet.add(wrapper.getHandler());\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46e9493c850d0ff2e6f30f455ad358251e1a2d48": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "JSR-356 - reworked Config to maintain user provided config\n\n+ If a user provided config is supplied, then that config should\n  be used for init(EndpointConfig) and other various accesses to\n  the configuration object.  This refactor stops using an internal\n  EndpointConfig object always and moves the internal config\n  fields into the JsrSession object instead.\n",
      "commitDate": "2013-07-09, 5:16 p.m.",
      "commitName": "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
      "commitAuthor": "Joakim Erdfelt",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "JSR-356 - reworked Config to maintain user provided config\n\n+ If a user provided config is supplied, then that config should\n  be used for init(EndpointConfig) and other various accesses to\n  the configuration object.  This refactor stops using an internal\n  EndpointConfig object always and moves the internal config\n  fields into the JsrSession object instead.\n",
          "commitDate": "2013-07-09, 5:16 p.m.",
          "commitName": "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
          "commitAuthor": "Joakim Erdfelt",
          "commitDateOld": "2013-04-15, 3:11 p.m.",
          "commitNameOld": "fe25ef0454e2be89a6aec8c87a1845ff8ecda1a2",
          "commitAuthorOld": "Joakim Erdfelt",
          "daysBetweenCommits": 85.09,
          "commitsBetweenForRepo": 417,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void addMessageHandler(MessageHandler handler) throws IllegalStateException\n    {\n        Objects.requireNonNull(handler,\"MessageHandler cannot be null\");\n\n        synchronized (wrappers)\n        {\n            for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass()))\n            {\n                DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n                MessageType key \u003d decoder.getMetadata().getMessageType();\n                MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n                if (other !\u003d null)\n                {\n                    StringBuilder err \u003d new StringBuilder();\n                    err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                    err.append(key.name());\n                    err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                    err.append(\"\u003c\");\n                    err.append(metadata.getMessageClass().getName());\n                    err.append(\"\u003e and \");\n                    err.append(other.getMetadata().getHandlerClass().getName());\n                    err.append(\"\u003c\");\n                    err.append(other.getMetadata().getMessageClass().getName());\n                    err.append(\"\u003e both implement this message type\");\n                    throw new IllegalStateException(err.toString());\n                }\n                else\n                {\n                    MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler,metadata,decoder);\n                    wrappers[key.ordinal()] \u003d wrapper;\n                }\n            }\n\n            // Update handlerSet\n            messageHandlerSet.clear();\n            for (MessageHandlerWrapper wrapper : wrappers)\n            {\n                if (wrapper \u003d\u003d null)\n                {\n                    // skip empty\n                    continue;\n                }\n                messageHandlerSet.add(wrapper.getHandler());\n            }\n        }\n    }",
          "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
          "functionStartLine": 99,
          "functionName": "addMessageHandler",
          "diff": "@@ -1,4 +1,46 @@\n-    public void addMessageHandler(MessageHandler listener) throws IllegalStateException\n+    public void addMessageHandler(MessageHandler handler) throws IllegalStateException\n     {\n-        this.messageHandlers.add(listener);\n+        Objects.requireNonNull(handler,\"MessageHandler cannot be null\");\n+\n+        synchronized (wrappers)\n+        {\n+            for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass()))\n+            {\n+                DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n+                MessageType key \u003d decoder.getMetadata().getMessageType();\n+                MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n+                if (other !\u003d null)\n+                {\n+                    StringBuilder err \u003d new StringBuilder();\n+                    err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n+                    err.append(key.name());\n+                    err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n+                    err.append(\"\u003c\");\n+                    err.append(metadata.getMessageClass().getName());\n+                    err.append(\"\u003e and \");\n+                    err.append(other.getMetadata().getHandlerClass().getName());\n+                    err.append(\"\u003c\");\n+                    err.append(other.getMetadata().getMessageClass().getName());\n+                    err.append(\"\u003e both implement this message type\");\n+                    throw new IllegalStateException(err.toString());\n+                }\n+                else\n+                {\n+                    MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler,metadata,decoder);\n+                    wrappers[key.ordinal()] \u003d wrapper;\n+                }\n+            }\n+\n+            // Update handlerSet\n+            messageHandlerSet.clear();\n+            for (MessageHandlerWrapper wrapper : wrappers)\n+            {\n+                if (wrapper \u003d\u003d null)\n+                {\n+                    // skip empty\n+                    continue;\n+                }\n+                messageHandlerSet.add(wrapper.getHandler());\n+            }\n+        }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[listener-MessageHandler]",
            "newValue": "[handler-MessageHandler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "JSR-356 - reworked Config to maintain user provided config\n\n+ If a user provided config is supplied, then that config should\n  be used for init(EndpointConfig) and other various accesses to\n  the configuration object.  This refactor stops using an internal\n  EndpointConfig object always and moves the internal config\n  fields into the JsrSession object instead.\n",
          "commitDate": "2013-07-09, 5:16 p.m.",
          "commitName": "46e9493c850d0ff2e6f30f455ad358251e1a2d48",
          "commitAuthor": "Joakim Erdfelt",
          "commitDateOld": "2013-04-15, 3:11 p.m.",
          "commitNameOld": "fe25ef0454e2be89a6aec8c87a1845ff8ecda1a2",
          "commitAuthorOld": "Joakim Erdfelt",
          "daysBetweenCommits": 85.09,
          "commitsBetweenForRepo": 417,
          "commitsBetweenForFile": 1,
          "actualSource": "    public void addMessageHandler(MessageHandler handler) throws IllegalStateException\n    {\n        Objects.requireNonNull(handler,\"MessageHandler cannot be null\");\n\n        synchronized (wrappers)\n        {\n            for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass()))\n            {\n                DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n                MessageType key \u003d decoder.getMetadata().getMessageType();\n                MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n                if (other !\u003d null)\n                {\n                    StringBuilder err \u003d new StringBuilder();\n                    err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n                    err.append(key.name());\n                    err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n                    err.append(\"\u003c\");\n                    err.append(metadata.getMessageClass().getName());\n                    err.append(\"\u003e and \");\n                    err.append(other.getMetadata().getHandlerClass().getName());\n                    err.append(\"\u003c\");\n                    err.append(other.getMetadata().getMessageClass().getName());\n                    err.append(\"\u003e both implement this message type\");\n                    throw new IllegalStateException(err.toString());\n                }\n                else\n                {\n                    MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler,metadata,decoder);\n                    wrappers[key.ordinal()] \u003d wrapper;\n                }\n            }\n\n            // Update handlerSet\n            messageHandlerSet.clear();\n            for (MessageHandlerWrapper wrapper : wrappers)\n            {\n                if (wrapper \u003d\u003d null)\n                {\n                    // skip empty\n                    continue;\n                }\n                messageHandlerSet.add(wrapper.getHandler());\n            }\n        }\n    }",
          "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
          "functionStartLine": 99,
          "functionName": "addMessageHandler",
          "diff": "@@ -1,4 +1,46 @@\n-    public void addMessageHandler(MessageHandler listener) throws IllegalStateException\n+    public void addMessageHandler(MessageHandler handler) throws IllegalStateException\n     {\n-        this.messageHandlers.add(listener);\n+        Objects.requireNonNull(handler,\"MessageHandler cannot be null\");\n+\n+        synchronized (wrappers)\n+        {\n+            for (MessageHandlerMetadata metadata : messageHandlerFactory.getMetadata(handler.getClass()))\n+            {\n+                DecoderWrapper decoder \u003d decoderFactory.getWrapperFor(metadata.getMessageClass());\n+                MessageType key \u003d decoder.getMetadata().getMessageType();\n+                MessageHandlerWrapper other \u003d wrappers[key.ordinal()];\n+                if (other !\u003d null)\n+                {\n+                    StringBuilder err \u003d new StringBuilder();\n+                    err.append(\"Encountered duplicate MessageHandler handling message type \u003c\");\n+                    err.append(key.name());\n+                    err.append(\"\u003e, \").append(metadata.getHandlerClass().getName());\n+                    err.append(\"\u003c\");\n+                    err.append(metadata.getMessageClass().getName());\n+                    err.append(\"\u003e and \");\n+                    err.append(other.getMetadata().getHandlerClass().getName());\n+                    err.append(\"\u003c\");\n+                    err.append(other.getMetadata().getMessageClass().getName());\n+                    err.append(\"\u003e both implement this message type\");\n+                    throw new IllegalStateException(err.toString());\n+                }\n+                else\n+                {\n+                    MessageHandlerWrapper wrapper \u003d new MessageHandlerWrapper(handler,metadata,decoder);\n+                    wrappers[key.ordinal()] \u003d wrapper;\n+                }\n+            }\n+\n+            // Update handlerSet\n+            messageHandlerSet.clear();\n+            for (MessageHandlerWrapper wrapper : wrappers)\n+            {\n+                if (wrapper \u003d\u003d null)\n+                {\n+                    // skip empty\n+                    continue;\n+                }\n+                messageHandlerSet.add(wrapper.getHandler());\n+            }\n+        }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d1692733f56b7c67a885b8c9fdd14fa204c8cab6": {
      "type": "Ybodychange",
      "commitMessage": "JSR-356: MessageHandler(s) layer\n",
      "commitDate": "2013-04-04, 3:03 p.m.",
      "commitName": "d1692733f56b7c67a885b8c9fdd14fa204c8cab6",
      "commitAuthor": "Joakim Erdfelt",
      "commitDateOld": "2013-03-28, 1:51 p.m.",
      "commitNameOld": "3a66b3ec3f8d608140be000dbec507ffd55a503b",
      "commitAuthorOld": "Joakim Erdfelt",
      "daysBetweenCommits": 7.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void addMessageHandler(MessageHandler listener) throws IllegalStateException\n    {\n        this.messageHandlers.add(listener);\n    }",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 66,
      "functionName": "addMessageHandler",
      "diff": "@@ -1,4 +1,4 @@\n     public void addMessageHandler(MessageHandler listener) throws IllegalStateException\n     {\n-        messageHandlers.add(listener);\n+        this.messageHandlers.add(listener);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a66b3ec3f8d608140be000dbec507ffd55a503b": {
      "type": "Ybodychange",
      "commitMessage": "JSR-356 first working annotated @ClientEndpoint echo test\n",
      "commitDate": "2013-03-28, 1:51 p.m.",
      "commitName": "3a66b3ec3f8d608140be000dbec507ffd55a503b",
      "commitAuthor": "Joakim Erdfelt",
      "commitDateOld": "2013-03-26, 8:30 p.m.",
      "commitNameOld": "fc7526b7392e132f63110258964b45d818947215",
      "commitAuthorOld": "Joakim Erdfelt",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public void addMessageHandler(MessageHandler listener) throws IllegalStateException\n    {\n        messageHandlers.add(listener);\n    }",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 64,
      "functionName": "addMessageHandler",
      "diff": "@@ -1,4 +1,4 @@\n     public void addMessageHandler(MessageHandler listener) throws IllegalStateException\n     {\n-        // TODO Auto-generated method stub\n+        messageHandlers.add(listener);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43231d84510fde66c4a19a5aac4782eaef15de16": {
      "type": "Yintroduced",
      "commitMessage": "393473 - Add support for JSR-356 (javax.websocket) draft\n\n + Restarting branch, copying over work from November with new JSR-356\n   Draft 012 api in mind.\n",
      "commitDate": "2013-02-12, 6:19 p.m.",
      "commitName": "43231d84510fde66c4a19a5aac4782eaef15de16",
      "commitAuthor": "Joakim Erdfelt",
      "diff": "@@ -0,0 +1,4 @@\n+    public void addMessageHandler(MessageHandler listener) throws IllegalStateException\n+    {\n+        // TODO Auto-generated method stub\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void addMessageHandler(MessageHandler listener) throws IllegalStateException\n    {\n        // TODO Auto-generated method stub\n    }",
      "path": "jetty-websocket/javax-websocket-client-impl/src/main/java/org/eclipse/jetty/websocket/jsr356/JsrSession.java",
      "functionStartLine": 58,
      "functionName": "addMessageHandler"
    }
  }
}