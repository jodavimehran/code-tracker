{
  "origin": "codeshovel",
  "repositoryName": "lucene-solr",
  "repositoryPath": "H:\\Projects\\apache\\lucene-solr/.git",
  "startCommitName": "38bf976cd4b9e324c21664bd7ae3d554df803705",
  "sourceFileName": "MemoryIndex.java",
  "functionName": "storeDocValues",
  "functionId": "storeDocValues___info-Info__docValuesType-DocValuesType__docValuesValue-Object",
  "sourceFilePath": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
  "functionStartLine": 515,
  "functionEndLine": 566,
  "numCommitsSeen": 110,
  "timeTaken": 3092,
  "changeHistory": [
    "e7a0a12926c399758a4021715a7419e22e59dab6",
    "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a",
    "a2d927667418d17a1f5f31a193092d5b04a4219e",
    "cf3eea26406692306505d2606d7ff73ee3634c30"
  ],
  "changeHistoryShort": {
    "e7a0a12926c399758a4021715a7419e22e59dab6": "Ybodychange",
    "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a": "Ybodychange",
    "a2d927667418d17a1f5f31a193092d5b04a4219e": "Ybodychange",
    "cf3eea26406692306505d2606d7ff73ee3634c30": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e7a0a12926c399758a4021715a7419e22e59dab6": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-8335: Enforce soft-deletes field up-front\n\nSoft deletes field must be marked as such once it\u0027s introduced\nand can\u0027t be changed after the fact.\n\nCo-authored-by: Nhat Nguyen \u003cnhat.nguyen@elastic.co\u003e\n",
      "commitDate": "2018-06-04, 2:28 a.m.",
      "commitName": "e7a0a12926c399758a4021715a7419e22e59dab6",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2018-06-02, 7:47 a.m.",
      "commitNameOld": "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "  private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n    String fieldName \u003d info.fieldInfo.name;\n    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n      // first time we add doc values for this field:\n      info.fieldInfo \u003d new FieldInfo(\n          info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n          info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField()\n      );\n    } else if (existingDocValuesType !\u003d docValuesType) {\n      throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n    }\n    switch (docValuesType) {\n      case NUMERIC:\n        if (info.numericProducer.dvLongValues !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.numericProducer.dvLongValues \u003d new long[]{(long) docValuesValue};\n        info.numericProducer.count++;\n        break;\n      case SORTED_NUMERIC:\n        if (info.numericProducer.dvLongValues \u003d\u003d null) {\n          info.numericProducer.dvLongValues \u003d new long[4];\n        }\n        info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n        info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n        break;\n      case BINARY:\n        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      case SORTED:\n        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      case SORTED_SET:\n        if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n          info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        }\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n  }",
      "path": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
      "functionStartLine": 515,
      "functionName": "storeDocValues",
      "diff": "@@ -1,52 +1,52 @@\n   private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName \u003d info.fieldInfo.name;\n     DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n       // first time we add doc values for this field:\n       info.fieldInfo \u003d new FieldInfo(\n           info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n           info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n-          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n+          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField()\n       );\n     } else if (existingDocValuesType !\u003d docValuesType) {\n       throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch (docValuesType) {\n       case NUMERIC:\n         if (info.numericProducer.dvLongValues !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.numericProducer.dvLongValues \u003d new long[]{(long) docValuesValue};\n         info.numericProducer.count++;\n         break;\n       case SORTED_NUMERIC:\n         if (info.numericProducer.dvLongValues \u003d\u003d null) {\n           info.numericProducer.dvLongValues \u003d new long[4];\n         }\n         info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n         info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n         break;\n       case BINARY:\n         if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED:\n         if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED_SET:\n         if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n           info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         }\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       default:\n         throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"LUCENE-8335: Enforce soft-deletes field up-front.\"\n\nThis reverts commit a2d927667418d17a1f5f31a193092d5b04a4219e.\n",
      "commitDate": "2018-06-02, 7:47 a.m.",
      "commitName": "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2018-06-02, 7:14 a.m.",
      "commitNameOld": "a2d927667418d17a1f5f31a193092d5b04a4219e",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n    String fieldName \u003d info.fieldInfo.name;\n    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n      // first time we add doc values for this field:\n      info.fieldInfo \u003d new FieldInfo(\n          info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n          info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n      );\n    } else if (existingDocValuesType !\u003d docValuesType) {\n      throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n    }\n    switch (docValuesType) {\n      case NUMERIC:\n        if (info.numericProducer.dvLongValues !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.numericProducer.dvLongValues \u003d new long[]{(long) docValuesValue};\n        info.numericProducer.count++;\n        break;\n      case SORTED_NUMERIC:\n        if (info.numericProducer.dvLongValues \u003d\u003d null) {\n          info.numericProducer.dvLongValues \u003d new long[4];\n        }\n        info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n        info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n        break;\n      case BINARY:\n        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      case SORTED:\n        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      case SORTED_SET:\n        if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n          info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        }\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n  }",
      "path": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
      "functionStartLine": 515,
      "functionName": "storeDocValues",
      "diff": "@@ -1,52 +1,52 @@\n   private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName \u003d info.fieldInfo.name;\n     DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n       // first time we add doc values for this field:\n       info.fieldInfo \u003d new FieldInfo(\n           info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n           info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n-          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField()\n+          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n       );\n     } else if (existingDocValuesType !\u003d docValuesType) {\n       throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch (docValuesType) {\n       case NUMERIC:\n         if (info.numericProducer.dvLongValues !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.numericProducer.dvLongValues \u003d new long[]{(long) docValuesValue};\n         info.numericProducer.count++;\n         break;\n       case SORTED_NUMERIC:\n         if (info.numericProducer.dvLongValues \u003d\u003d null) {\n           info.numericProducer.dvLongValues \u003d new long[4];\n         }\n         info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n         info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n         break;\n       case BINARY:\n         if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED:\n         if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED_SET:\n         if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n           info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         }\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       default:\n         throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2d927667418d17a1f5f31a193092d5b04a4219e": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-8335: Enforce soft-deletes field up-front.\n\nSoft deletes field must be marked as such once it\u0027s introduced\nand can\u0027t be changed after the fact.\n",
      "commitDate": "2018-06-02, 7:14 a.m.",
      "commitName": "a2d927667418d17a1f5f31a193092d5b04a4219e",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": "2018-05-02, 8:49 a.m.",
      "commitNameOld": "af680af77f3f80c779e038a0ad8a136c9dcb9f5d",
      "commitAuthorOld": "Adrien Grand",
      "daysBetweenCommits": 30.93,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "actualSource": "  private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n    String fieldName \u003d info.fieldInfo.name;\n    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n      // first time we add doc values for this field:\n      info.fieldInfo \u003d new FieldInfo(\n          info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n          info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField()\n      );\n    } else if (existingDocValuesType !\u003d docValuesType) {\n      throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n    }\n    switch (docValuesType) {\n      case NUMERIC:\n        if (info.numericProducer.dvLongValues !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.numericProducer.dvLongValues \u003d new long[]{(long) docValuesValue};\n        info.numericProducer.count++;\n        break;\n      case SORTED_NUMERIC:\n        if (info.numericProducer.dvLongValues \u003d\u003d null) {\n          info.numericProducer.dvLongValues \u003d new long[4];\n        }\n        info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n        info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n        break;\n      case BINARY:\n        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      case SORTED:\n        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      case SORTED_SET:\n        if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n          info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        }\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n  }",
      "path": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
      "functionStartLine": 515,
      "functionName": "storeDocValues",
      "diff": "@@ -1,52 +1,52 @@\n   private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName \u003d info.fieldInfo.name;\n     DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n       // first time we add doc values for this field:\n       info.fieldInfo \u003d new FieldInfo(\n           info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n           info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n-          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n+          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField()\n       );\n     } else if (existingDocValuesType !\u003d docValuesType) {\n       throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch (docValuesType) {\n       case NUMERIC:\n         if (info.numericProducer.dvLongValues !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.numericProducer.dvLongValues \u003d new long[]{(long) docValuesValue};\n         info.numericProducer.count++;\n         break;\n       case SORTED_NUMERIC:\n         if (info.numericProducer.dvLongValues \u003d\u003d null) {\n           info.numericProducer.dvLongValues \u003d new long[4];\n         }\n         info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n         info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n         break;\n       case BINARY:\n         if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED:\n         if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED_SET:\n         if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n           info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n         }\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       default:\n         throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cf3eea26406692306505d2606d7ff73ee3634c30": {
      "type": "Yintroduced",
      "commitMessage": "LUCENE-7091: Added doc values support to memory index\n",
      "commitDate": "2016-03-15, 4:57 a.m.",
      "commitName": "cf3eea26406692306505d2606d7ff73ee3634c30",
      "commitAuthor": "Martijn van Groningen",
      "diff": "@@ -0,0 +1,52 @@\n+  private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n+    String fieldName \u003d info.fieldInfo.name;\n+    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n+    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n+      // first time we add doc values for this field:\n+      info.fieldInfo \u003d new FieldInfo(\n+          info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n+          info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n+          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n+      );\n+    } else if (existingDocValuesType !\u003d docValuesType) {\n+      throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n+    }\n+    switch (docValuesType) {\n+      case NUMERIC:\n+        if (info.numericProducer.dvLongValues !\u003d null) {\n+          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+        }\n+        info.numericProducer.dvLongValues \u003d new long[]{(long) docValuesValue};\n+        info.numericProducer.count++;\n+        break;\n+      case SORTED_NUMERIC:\n+        if (info.numericProducer.dvLongValues \u003d\u003d null) {\n+          info.numericProducer.dvLongValues \u003d new long[4];\n+        }\n+        info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n+        info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n+        break;\n+      case BINARY:\n+        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n+          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+        }\n+        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n+        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+        break;\n+      case SORTED:\n+        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n+          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+        }\n+        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n+        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+        break;\n+      case SORTED_SET:\n+        if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n+          info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n+        }\n+        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+        break;\n+      default:\n+        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n    String fieldName \u003d info.fieldInfo.name;\n    DocValuesType existingDocValuesType \u003d info.fieldInfo.getDocValuesType();\n    if (existingDocValuesType \u003d\u003d DocValuesType.NONE) {\n      // first time we add doc values for this field:\n      info.fieldInfo \u003d new FieldInfo(\n          info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n          info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n      );\n    } else if (existingDocValuesType !\u003d docValuesType) {\n      throw new IllegalArgumentException(\"Can\u0027t add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n    }\n    switch (docValuesType) {\n      case NUMERIC:\n        if (info.numericProducer.dvLongValues !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.numericProducer.dvLongValues \u003d new long[]{(long) docValuesValue};\n        info.numericProducer.count++;\n        break;\n      case SORTED_NUMERIC:\n        if (info.numericProducer.dvLongValues \u003d\u003d null) {\n          info.numericProducer.dvLongValues \u003d new long[4];\n        }\n        info.numericProducer.dvLongValues \u003d ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n        info.numericProducer.dvLongValues[info.numericProducer.count++] \u003d (long) docValuesValue;\n        break;\n      case BINARY:\n        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      case SORTED:\n        if (info.binaryProducer.dvBytesValuesSet !\u003d null) {\n          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n        }\n        info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      case SORTED_SET:\n        if (info.binaryProducer.dvBytesValuesSet \u003d\u003d null) {\n          info.binaryProducer.dvBytesValuesSet \u003d new BytesRefHash(byteBlockPool);\n        }\n        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n  }",
      "path": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
      "functionStartLine": 515,
      "functionName": "storeDocValues"
    }
  }
}